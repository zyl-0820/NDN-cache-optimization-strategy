generated_code = ""

# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from compiler/utils/codegen.sugar.py), do not modify directly.
# Generator: PPK

global file_indentation_level
file_indentation_level = 0

# The last element is the innermost (current) style.
file_sugar_style = ['line_comment']


def add_code(line, lineno = None, file = "compiler/utils/codegen.sugar.py"):
    global file_indentation_level
    global file_sugar_style
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
    }

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = '    ' * file_indentation_level
    return indent + line + sugar(no_sugar_on_line, file, lineno) + line_ends[file_sugar_style[-1]]


class SugarStyle():
    def __init__(self, sugar):
        global file_sugar_style
        file_sugar_style.append(sugar)

    def __enter__(self):
        global file_sugar_style
        return file_sugar_style[-1]

    def __exit__(self, type, value, traceback):
        global file_sugar_style
        file_sugar_style.pop()


def sugar(no_sugar_on_line, file, lineno):
    if no_sugar_on_line or file is None or lineno is None:
        return ""

    import re
    global file_sugar_style

    if file_sugar_style[-1] == 'line_comment':
        if no_sugar_on_line:
            return ""
        return " // {}:{}".format(file, lineno)
    if file_sugar_style[-1] == 'inline_comment':
        if file == "../compiler/utils/codegen.sugar.py":
            return " /* {} */ {}".format(lineno)
        return " /* {}:{} */".format(file, lineno)
    return line


generated_code += "// Autogenerated file (from compiler/utils/codegen.sugar.py via ../compiler/utils/codegen.sugar.py), do not modify directly.\n"
generated_code += "// Generator: PPK\n"
generated_code += "\n"

# Copyright 2017 Eotvos Lorand University, Budapest, Hungary ## compiler/utils/codegen.sugar.py:1
#  ## compiler/utils/codegen.sugar.py:2
# Licensed under the Apache License, Version 2.0 (the "License"); ## compiler/utils/codegen.sugar.py:3
# you may not use this file except in compliance with the License. ## compiler/utils/codegen.sugar.py:4
# You may obtain a copy of the License at ## compiler/utils/codegen.sugar.py:5
#  ## compiler/utils/codegen.sugar.py:6
#     http://www.apache.org/licenses/LICENSE-2.0 ## compiler/utils/codegen.sugar.py:7
#  ## compiler/utils/codegen.sugar.py:8
# Unless required by applicable law or agreed to in writing, software ## compiler/utils/codegen.sugar.py:9
# distributed under the License is distributed on an "AS IS" BASIS, ## compiler/utils/codegen.sugar.py:10
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ## compiler/utils/codegen.sugar.py:11
# See the License for the specific language governing permissions and ## compiler/utils/codegen.sugar.py:12
# limitations under the License. ## compiler/utils/codegen.sugar.py:13

from utils.misc import addWarning, addError ## compiler/utils/codegen.sugar.py:15
import re ## compiler/utils/codegen.sugar.py:16
################################################################################ ## compiler/utils/codegen.sugar.py:17

SHORT_STDPARAMS = "packet_descriptor_t* pd, lookup_table_t** tables" ## compiler/utils/codegen.sugar.py:19
SHORT_STDPARAMS_IN = "pd, tables" ## compiler/utils/codegen.sugar.py:20
STDPARAMS = SHORT_STDPARAMS + ", parser_state_t* pstate" ## compiler/utils/codegen.sugar.py:21
STDPARAMS_IN = SHORT_STDPARAMS_IN + ", pstate" ## compiler/utils/codegen.sugar.py:22

################################################################################ ## compiler/utils/codegen.sugar.py:24

type_env = {} ## compiler/utils/codegen.sugar.py:26

def gen_format_type(t, resolve_names = True, use_array = False, addon = ""): ## compiler/utils/codegen.sugar.py:28
    generated_code = ""
    """Returns a type. If the type has a part that has to come after the variable name in a declaration, ## compiler/utils/codegen.sugar.py:29
    such as [20] in uint8_t varname[20], it should be separated with a space.""" ## compiler/utils/codegen.sugar.py:30
    if t.node_type == 'Type_Specialized': ## compiler/utils/codegen.sugar.py:31
        extern_name = t.baseType.path.name ## compiler/utils/codegen.sugar.py:32

        # TODO is there a more straightforward way to deal with such externs? ## compiler/utils/codegen.sugar.py:34
        argtyped_externs = ["Digest"] ## compiler/utils/codegen.sugar.py:35

        if extern_name in argtyped_externs: ## compiler/utils/codegen.sugar.py:37
            generated_code += add_code(' {}'.format(t.arguments[0].type_ref.name), 37)
        else: ## compiler/utils/codegen.sugar.py:39
            param_count = len(t.baseType.type_ref.typeParameters.parameters) ## compiler/utils/codegen.sugar.py:40
            if param_count != 1: ## compiler/utils/codegen.sugar.py:41
                addError('formatting type', 'Type {} has {} parameters; only 1 parameter is supported'.format(t.name, param_count)) ## compiler/utils/codegen.sugar.py:42

            type_name = gen_format_type(t.arguments[0]._type_ref, resolve_names) ## compiler/utils/codegen.sugar.py:44
            generated_code += add_code(' {}_{}'.format(extern_name, type_name), 44)
    elif t.node_type == 'Type_Void': ## compiler/utils/codegen.sugar.py:46
        generated_code += add_code(" void", 46)
    elif t.node_type == 'Type_Boolean': ## compiler/utils/codegen.sugar.py:48
        generated_code += add_code(" bool", 48)
    elif t.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:50
        res = 'int' if t.isSigned else 'uint' ## compiler/utils/codegen.sugar.py:51
        if t.size <= 8: ## compiler/utils/codegen.sugar.py:52
            res += '8_t' ## compiler/utils/codegen.sugar.py:53
        elif t.size <= 16: ## compiler/utils/codegen.sugar.py:54
            res += '16_t' ## compiler/utils/codegen.sugar.py:55
        elif t.size <= 32: ## compiler/utils/codegen.sugar.py:56
            res += '32_t' ## compiler/utils/codegen.sugar.py:57
        elif use_array: ## compiler/utils/codegen.sugar.py:58
            res += '8_t [{}]'.format((t.size+7)/8) ## compiler/utils/codegen.sugar.py:59
        else: ## compiler/utils/codegen.sugar.py:60
            res += '8_t*' ## compiler/utils/codegen.sugar.py:61
        return res ## compiler/utils/codegen.sugar.py:62
    elif t.node_type == 'Type_Name': ## compiler/utils/codegen.sugar.py:63
        if t.type_ref.node_type in {'Type_Enum', 'Type_Error'}: ## compiler/utils/codegen.sugar.py:64
            generated_code += add_code(' enum {}'.format(t.type_ref.c_name), 64)
        else: ## compiler/utils/codegen.sugar.py:66
            if not resolve_names: ## compiler/utils/codegen.sugar.py:67
                return t.type_ref.name ## compiler/utils/codegen.sugar.py:68

            global type_env ## compiler/utils/codegen.sugar.py:70

            if t.type_ref.name in type_env: ## compiler/utils/codegen.sugar.py:72
                return type_env[t.type_ref.name] ## compiler/utils/codegen.sugar.py:73
            if t.type_ref.name=="P": ## compiler/utils/codegen.sugar.py:74
                generated_code += add_code(" uint32_t*", 74)
            else:     ## compiler/utils/codegen.sugar.py:76
                generated_code += add_code(' {}'.format(t.type_ref.name), 76)
    elif t.node_type == 'Type_Extern': ## compiler/utils/codegen.sugar.py:78
        generated_code += add_code(' {}_t'.format(t.name), 78)
    elif t.node_type == 'Type_Struct': ## compiler/utils/codegen.sugar.py:80
        struct_name = "{}_s".format(t.name[:-2]) if t.name.endswith("_t") else t.name ## compiler/utils/codegen.sugar.py:81
        generated_code += add_code(' struct {}'.format(struct_name), 81)
    elif t.node_type == 'Type_Varbits': ## compiler/utils/codegen.sugar.py:83
        generated_code += add_code(' uint8_t [{}] /* preliminary type for varbits */'.format((t.size+7)/8), 83)
    elif t.node_type == 'Type_Var': ## compiler/utils/codegen.sugar.py:85
        generated_code += add_code(" void", 85)
    else: ## compiler/utils/codegen.sugar.py:87
        addError('formatting type', 'Type {} for node ({}) is not supported yet!'.format(t.node_type, t)) ## compiler/utils/codegen.sugar.py:88
        generated_code += add_code(' int /* generated in place of unknown type {} */'.format(t.node_type), 88)

    return generated_code

def pp_type_16(t): ## compiler/utils/codegen.sugar.py:91
    """Pretty print P4_16 type""" ## compiler/utils/codegen.sugar.py:92
    if t.node_type == 'Type_Boolean': ## compiler/utils/codegen.sugar.py:93
        return 'bool' ## compiler/utils/codegen.sugar.py:94
    elif t.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:95
        return ('int' if t.isSigned else 'bit') + '<' + str(t.size) + '>' ## compiler/utils/codegen.sugar.py:96
    else: ## compiler/utils/codegen.sugar.py:97
        return str(t) ## compiler/utils/codegen.sugar.py:98

def gen_format_type_mask(t): ## compiler/utils/codegen.sugar.py:100
    generated_code = ""
    if t.node_type == 'Type_Bits' and not t.isSigned: ## compiler/utils/codegen.sugar.py:101
        mask = hex((2 ** t.size) - 1) ## compiler/utils/codegen.sugar.py:102
        generated_code += add_code(' {}&'.format(mask), 102)
    else: ## compiler/utils/codegen.sugar.py:104
        addError('formatting a type mask', 'Currently only bit<w> is supported!') ## compiler/utils/codegen.sugar.py:105

    return generated_code

def method_parameters_by_type(args, method_params): ## compiler/utils/codegen.sugar.py:107
    for (par, tpar) in zip(args, method_params.parameters): ## compiler/utils/codegen.sugar.py:108
        if tpar('type.type_ref.is_metadata', False): ## compiler/utils/codegen.sugar.py:109
            continue ## compiler/utils/codegen.sugar.py:110

        yield (par, tpar.type) ## compiler/utils/codegen.sugar.py:112

def format_method_parameter(par): ## compiler/utils/codegen.sugar.py:114
    if hasattr(par, 'field_ref'): ## compiler/utils/codegen.sugar.py:115
        return 'handle(header_desc_ins(pd, {}), {})'.format(par.expr.header_ref.id, par.expression.field_ref.id) ## compiler/utils/codegen.sugar.py:116
    else: ## compiler/utils/codegen.sugar.py:117
        # return format_expr(par)[0:m.expr.path.name.rfind("_")] ## compiler/utils/codegen.sugar.py:118
        return format_expr(par.expression,expand_parameters=True) ## compiler/utils/codegen.sugar.py:119

def gen_format_method_parameters(args, method_params): ## compiler/utils/codegen.sugar.py:121
    generated_code = ""
    c = [] ## compiler/utils/codegen.sugar.py:122
    for (par, tpar) in method_parameters_by_type(args, method_params): ## compiler/utils/codegen.sugar.py:123
        if hasattr(par.expression, 'field_ref'): ## compiler/utils/codegen.sugar.py:124
            name = "field_metadata_"+par.expression.field_ref.name ## compiler/utils/codegen.sugar.py:125
            c += [name] ## compiler/utils/codegen.sugar.py:126
        else: ## compiler/utils/codegen.sugar.py:127
            c += [format_method_parameter(par)] ## compiler/utils/codegen.sugar.py:128
    return ', '.join(c) ## compiler/utils/codegen.sugar.py:129
    #return ', '.join([format_method_parameter(par) for (par, tpar) in method_parameters_by_type(args, method_params)]) ## compiler/utils/codegen.sugar.py:130

    return generated_code

def gen_format_declaration(d, varname_override): ## compiler/utils/codegen.sugar.py:132
    generated_code = ""
    var_name = d.name if varname_override is None else varname_override ## compiler/utils/codegen.sugar.py:133

    if d.node_type == 'Declaration_Variable': ## compiler/utils/codegen.sugar.py:135
        if d.type('type_ref.node_type', 'not header') == 'Type_Header': ## compiler/utils/codegen.sugar.py:136
            # Data for variable width headers is stored in parser_state_t ## compiler/utils/codegen.sugar.py:137
            pass ## compiler/utils/codegen.sugar.py:138
        elif d.type.node_type == 'Type_Boolean': ## compiler/utils/codegen.sugar.py:139
            generated_code += add_code(' bool {} = false;'.format(var_name), 139)
        else: ## compiler/utils/codegen.sugar.py:141
            t = gen_format_type(d.type, False) ## compiler/utils/codegen.sugar.py:142
            generated_code += add_code(' {} {};'.format(t, var_name), 142)
    elif d.node_type == 'Declaration_Instance': ## compiler/utils/codegen.sugar.py:144
        t = gen_format_type(d.type, False) + "_t" ## compiler/utils/codegen.sugar.py:145
        generated_code += add_code(' extern void {}_init({}*);'.format(t, t), 145)
        generated_code += add_code(' {} {};'.format(t, var_name), 146)
        generated_code += add_code(' {}_init(&{});'.format(t, var_name), 147)
    elif d.node_type in ['P4Table', 'P4Action']: ## compiler/utils/codegen.sugar.py:149
        generated_code += add_code(" /* nothing */", 149)
    else: ## compiler/utils/codegen.sugar.py:151
        addError('formatting declaration', 'Declaration of type %s is not supported yet!' % d.node_type) ## compiler/utils/codegen.sugar.py:152

    return generated_code

################################################################################ ## compiler/utils/codegen.sugar.py:154

def is_metadata(e): ## compiler/utils/codegen.sugar.py:156
    if e.node_type == 'Member': ## compiler/utils/codegen.sugar.py:157
        if hasattr(e.expr, 'header_ref'): ## compiler/utils/codegen.sugar.py:158
            return e.expr.header_ref.type.type_ref.is_metadata ## compiler/utils/codegen.sugar.py:159
        elif hasattr(e.expr.type, 'is_metadata'): ## compiler/utils/codegen.sugar.py:160
            return e.expr.type.is_metadata ## compiler/utils/codegen.sugar.py:161
        else: ## compiler/utils/codegen.sugar.py:162
            return False ## compiler/utils/codegen.sugar.py:163
    return False ## compiler/utils/codegen.sugar.py:164


def is_std_metadata(e): ## compiler/utils/codegen.sugar.py:167
    return is_metadata(e) and e.expr.type.name == 'standard_metadata_t' ## compiler/utils/codegen.sugar.py:168

################################################################################ ## compiler/utils/codegen.sugar.py:170

enclosing_control = None ## compiler/utils/codegen.sugar.py:172

pre_statement_buffer = "" ## compiler/utils/codegen.sugar.py:174
post_statement_buffer = "" ## compiler/utils/codegen.sugar.py:175

def prepend_statement(s): ## compiler/utils/codegen.sugar.py:177
    global pre_statement_buffer ## compiler/utils/codegen.sugar.py:178
    pre_statement_buffer += "\n" + s ## compiler/utils/codegen.sugar.py:179

def append_statement(s): ## compiler/utils/codegen.sugar.py:181
    global post_statement_buffer ## compiler/utils/codegen.sugar.py:182
    post_statement_buffer += s + "\n" ## compiler/utils/codegen.sugar.py:183

def statement_buffer_value(): ## compiler/utils/codegen.sugar.py:185
    global pre_statement_buffer ## compiler/utils/codegen.sugar.py:186
    global post_statement_buffer ## compiler/utils/codegen.sugar.py:187
    ret = (pre_statement_buffer, post_statement_buffer) ## compiler/utils/codegen.sugar.py:188
    pre_statement_buffer = "" ## compiler/utils/codegen.sugar.py:189
    post_statement_buffer = "" ## compiler/utils/codegen.sugar.py:190
    return ret ## compiler/utils/codegen.sugar.py:191


def is_control_local_var(var_name): ## compiler/utils/codegen.sugar.py:194
    global enclosing_control ## compiler/utils/codegen.sugar.py:195

    def get_locals(node): ## compiler/utils/codegen.sugar.py:197
        if node.node_type == 'P4Parser':  return node.parserLocals ## compiler/utils/codegen.sugar.py:198
        if node.node_type == 'P4Control': return node.controlLocals ## compiler/utils/codegen.sugar.py:199
        return [] ## compiler/utils/codegen.sugar.py:200

    return enclosing_control is not None and [] != [cl for cl in get_locals(enclosing_control) if cl.name == var_name] ## compiler/utils/codegen.sugar.py:202


var_name_counter = 0 ## compiler/utils/codegen.sugar.py:205
generated_var_names = set() ## compiler/utils/codegen.sugar.py:206

def generate_var_name(var_name_part = "var", var_id = None): ## compiler/utils/codegen.sugar.py:208
    global var_name_counter ## compiler/utils/codegen.sugar.py:209
    global generated_var_names ## compiler/utils/codegen.sugar.py:210

    var_name_counter += 1 ## compiler/utils/codegen.sugar.py:212

    var_name = var_name_part + "_" + str(var_name_counter) ## compiler/utils/codegen.sugar.py:214
    if var_id is not None: ## compiler/utils/codegen.sugar.py:215
        simpler_var_name = var_name_part + "_" + var_id ## compiler/utils/codegen.sugar.py:216
        if simpler_var_name not in generated_var_names: ## compiler/utils/codegen.sugar.py:217
            var_name = simpler_var_name ## compiler/utils/codegen.sugar.py:218
        else: ## compiler/utils/codegen.sugar.py:219
            var_name = simpler_var_name + "_" + str(var_name_counter) ## compiler/utils/codegen.sugar.py:220

    generated_var_names.add(var_name) ## compiler/utils/codegen.sugar.py:222

    return var_name ## compiler/utils/codegen.sugar.py:224

################################################################################ ## compiler/utils/codegen.sugar.py:226

def int_to_big_endian_byte_array_with_length(value, width, base=10): ## compiler/utils/codegen.sugar.py:228
    array = [] ## compiler/utils/codegen.sugar.py:229
    while value > 0: ## compiler/utils/codegen.sugar.py:230
        array.append(int(value % 256)) ## compiler/utils/codegen.sugar.py:231
        value /= 256 ## compiler/utils/codegen.sugar.py:232
    array.reverse() ## compiler/utils/codegen.sugar.py:233
    array_len = len(array) ## compiler/utils/codegen.sugar.py:234
    padded_array = [0 for i in range(width-array_len)] + array[array_len-min(array_len, width) : array_len] ## compiler/utils/codegen.sugar.py:235
    return '{' + ', '.join([print_with_base(x, base) for x in padded_array]) + '}' ## compiler/utils/codegen.sugar.py:236


def bit_bounding_unit(t): ## compiler/utils/codegen.sugar.py:239
    """The bit width of the smallest int that can contain the type, ## compiler/utils/codegen.sugar.py:240
    or the string "bytebuf" if it is larger than all possible container types.""" ## compiler/utils/codegen.sugar.py:241
    if t.size <= 8: ## compiler/utils/codegen.sugar.py:242
        return "8" ## compiler/utils/codegen.sugar.py:243
    if t.size <= 16: ## compiler/utils/codegen.sugar.py:244
        return "16" ## compiler/utils/codegen.sugar.py:245
    if t.size <= 32: ## compiler/utils/codegen.sugar.py:246
        return "32" ## compiler/utils/codegen.sugar.py:247
    return "bytebuf" ## compiler/utils/codegen.sugar.py:248

def gen_extern_format_parameter(expr, par, packets_or_bytes_override = None): ## compiler/utils/codegen.sugar.py:250
    generated_code = ""
    def member_to_field_id(member): ## compiler/utils/codegen.sugar.py:251
        return 'field_{}_{}'.format(member.expr.type.name, member.member) ## compiler/utils/codegen.sugar.py:252

    # TODO ## compiler/utils/codegen.sugar.py:254
    # if packets_or_bytes_override: ## compiler/utils/codegen.sugar.py:255
    if par.direction == "in" or expr.node_type != "Member": ## compiler/utils/codegen.sugar.py:256
        prefix = "&" if par.direction != "in" and par.type.node_type != 'Type_Bits' else "" ## compiler/utils/codegen.sugar.py:257
        generated_code += add_code(' {}({})'.format(prefix, format_expr(expr, format_as_value=True, expand_parameters=True)), 257)
    else: ## compiler/utils/codegen.sugar.py:259
        expr_width = expr.type.size; ## compiler/utils/codegen.sugar.py:260

        member = "all_metadatas" if expr.expr.ref.type.type_ref.is_metadata else expr.expr.member if hasattr(expr.expr, 'member') else expr.member ## compiler/utils/codegen.sugar.py:262

        if expr_width<=32: ## compiler/utils/codegen.sugar.py:264
            expr_unit = bit_bounding_unit(expr.type) ## compiler/utils/codegen.sugar.py:265
            prepend_statement(' uint{}_t value_{}; // (prepended) compiler/utils/codegen.sugar.py:265\n'.format(expr_unit, expr.id)) ## compiler/utils/codegen.sugar.py:266
            if par.direction=="inout": ## compiler/utils/codegen.sugar.py:267
                prepend_statement(' value_{} = {}; // (prepended) compiler/utils/codegen.sugar.py:267\n'.format(expr.id, format_expr(expr))) ## compiler/utils/codegen.sugar.py:268
            append_statement(' set_field((fldT[]){{{{pd, header_instance_{}, {} }}}}, 0, value_{}, {}); // (appended) compiler/utils/codegen.sugar.py:268\n'.format(member, member_to_field_id(expr), expr.id, expr_width)) ## compiler/utils/codegen.sugar.py:269
            generated_code += add_code(' &value_{}'.format(expr.id), 269)
        else: ## compiler/utils/codegen.sugar.py:271
            prepend_statement(' uint8_t value_{}[{}]; // (prepended) compiler/utils/codegen.sugar.py:271\n'.format(expr.id, (int)((expr_width+7)/8))) ## compiler/utils/codegen.sugar.py:272
            if par.direction=="inout": ## compiler/utils/codegen.sugar.py:273
                prepend_statement(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, {}, value_{}); // (prepended) compiler/utils/codegen.sugar.py:273\n'.format(member, member_to_field_id(expr), expr.id)) ## compiler/utils/codegen.sugar.py:274
            append_statement(' MODIFY_BYTEBUF_BYTEBUF_PACKET(pd, header_instance_{}, {}, value_{}, {}); // (appended) compiler/utils/codegen.sugar.py:274\n'.format(member, member_to_field_id(expr), expr.id, expr_width)) ## compiler/utils/codegen.sugar.py:275
            generated_code += add_code(' value_{}'.format(expr.id), 275)




    return generated_code

def member_to_field_id(member): ## compiler/utils/codegen.sugar.py:281
    return 'field_{}_{}'.format(member.expr.type.name, member.member) ## compiler/utils/codegen.sugar.py:282

def gen_format_statement_fieldref_wide(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id): ## compiler/utils/codegen.sugar.py:284
    generated_code = ""
    if src.node_type == 'Member': ## compiler/utils/codegen.sugar.py:285
        src_pointer = 'tmp_fldref_{}'.format(src.id) ## compiler/utils/codegen.sugar.py:286
        generated_code += add_code(' uint8_t {}[{}];'.format(src_pointer, dst_bytewidth), 286)

        if hasattr(src, 'field_ref'): ## compiler/utils/codegen.sugar.py:289
            hdrinst = 'all_metadatas' if src.expr.type.is_metadata else src.expr.member ## compiler/utils/codegen.sugar.py:290
            generated_code += add_code(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, {}, {})'.format(hdrinst, member_to_field_id(src), src_pointer), 290)
            if dst_is_vw: ## compiler/utils/codegen.sugar.py:292
                src_vw_bitwidth = 'pd->headers[header_instance_{}].var_width_field_bitwidth'.format(src.expr.member) ## compiler/utils/codegen.sugar.py:293
                dst_bytewidth = '({}/8)'.format(src_vw_bitwidth) ## compiler/utils/codegen.sugar.py:294
        else: ## compiler/utils/codegen.sugar.py:295
            srcname = src.expr.ref.name ## compiler/utils/codegen.sugar.py:296
            generated_code += add_code(' EXTRACT_BYTEBUF_BUFFER(pstate->{}, pstate->{}_var, {}, {})'.format(srcname, srcname, member_to_field_id(src), src_pointer), 296)
            if dst_is_vw: ## compiler/utils/codegen.sugar.py:298
                src_vw_bitwidth = 'pstate->{}_var'.format(src.expr.ref.name) ## compiler/utils/codegen.sugar.py:299
                dst_bytewidth = '({}/8)'.format(src_vw_bitwidth) ## compiler/utils/codegen.sugar.py:300
    elif src.node_type == 'PathExpression': ## compiler/utils/codegen.sugar.py:301
        refbase = "local_vars->" if is_control_local_var(src.ref.name) else 'parameters.' ## compiler/utils/codegen.sugar.py:302
        src_pointer = '{}{}'.format(refbase, src.ref.name) ## compiler/utils/codegen.sugar.py:303
    elif src.node_type == 'Constant': ## compiler/utils/codegen.sugar.py:304
        src_pointer = 'tmp_fldref_{}'.format(src.id) ## compiler/utils/codegen.sugar.py:305
        generated_code += add_code(' uint8_t {}[{}] = {};'.format(src_pointer, dst_bytewidth, int_to_big_endian_byte_array_with_length(src.value, dst_bytewidth, src.base)), 305)
    elif src.node_type == 'Mux': ## compiler/utils/codegen.sugar.py:307
        src_pointer = 'tmp_fldref_{}'.format(src.id) ## compiler/utils/codegen.sugar.py:308
        generated_code += add_code(' uint8_t {}[{}] = (({}) == ({})) ? ({}) : ({});'.format(src_pointer, dst_bytewidth, format_expr(src.e0.left), format_expr(src.e0.right), format_expr(src.e1), format_expr(src.e2)), 308)
    else: ## compiler/utils/codegen.sugar.py:310
        src_pointer = 'NOT_SUPPORTED' ## compiler/utils/codegen.sugar.py:311
        addError('formatting statement', 'Assignment to unsupported field in: {} = {}'.format(format_expr(dst), src)) ## compiler/utils/codegen.sugar.py:312
    dst_fixed_size = dst.expr.header_ref.type.type_ref.bit_width - dst.field_ref.size ## compiler/utils/codegen.sugar.py:313

    if dst_is_vw: ## compiler/utils/codegen.sugar.py:315
        generated_code += add_code(' pd->headers[{}].var_width_field_bitwidth = get_var_width_bitwidth(pstate);'.format(dst_header_id), 315)
        generated_code += add_code(' pd->headers[{}].length = ({} + pd->headers[{}].var_width_field_bitwidth)/8;'.format(dst_header_id, dst_fixed_size, dst_header_id), 316)

    generated_code += add_code(' MODIFY_BYTEBUF_BYTEBUF_PACKET(pd, {}, {}, {}, {})'.format(dst_header_id, dst_field_id, src_pointer, dst_bytewidth), 318)

    generated_code += add_code(' dbg_bytes({}, {},'.format(src_pointer, dst_bytewidth), 320)
    generated_code += add_code("      \"    \" T4LIT(=,field) \" Modifying field \" T4LIT(%s,header) \".\" T4LIT(%s,field) \"/\" T4LIT(%d) \"b (\" T4LIT(%d) \"B) = \",", 321)
    generated_code += add_code('      header_instance_names[{}],'.format(dst_header_id), 322)
    generated_code += add_code('      field_names[{}], // {}'.format(dst_field_id, dst_field_id), 323)
    generated_code += add_code('      {}*8,'.format(dst_bytewidth), 324)
    generated_code += add_code('      {}'.format(dst_bytewidth), 325)
    generated_code += add_code("      );", 326)

    generated_code += add_code(' dbg_bytes(pd->headers[{}].pointer + (160/8), {},'.format(dst_header_id, dst_bytewidth), 328)
    generated_code += add_code("      \"    \" T4LIT(=,field) \" Modifying field \" T4LIT(%s,header) \".\" T4LIT(%s,field) \"/\" T4LIT(%d) \"b (\" T4LIT(%d) \"B) = \",", 329)
    generated_code += add_code('      header_instance_names[{}],'.format(dst_header_id), 330)
    generated_code += add_code('      field_names[{}], // {}'.format(dst_field_id, dst_field_id), 331)
    generated_code += add_code('      {}*8,'.format(dst_bytewidth), 332)
    generated_code += add_code('      {}'.format(dst_bytewidth), 333)
    generated_code += add_code("      );", 334)

    return generated_code

def is_primitive(typenode): ## compiler/utils/codegen.sugar.py:337
    """Returns true if the argument node is compiled to a non-reference C type.""" ## compiler/utils/codegen.sugar.py:338
    # TODO determine better if the source is a reference or not ## compiler/utils/codegen.sugar.py:339
    return typenode.node_type in ["Type_Boolean"] or (typenode.node_type == 'Type_Bits' and typenode.size <= 32) ## compiler/utils/codegen.sugar.py:340


def gen_format_statement_fieldref_short(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id): ## compiler/utils/codegen.sugar.py:343
    generated_code = ""
    src_buffer = 'value32' ## compiler/utils/codegen.sugar.py:344
    if src.node_type == 'Member': ## compiler/utils/codegen.sugar.py:345
        generated_code += add_code(' {} = {};'.format(src_buffer, format_expr(src)), 345)
    elif src.node_type == 'PathExpression': ## compiler/utils/codegen.sugar.py:347
        indirection = "&" if is_primitive(src.type) else "" ## compiler/utils/codegen.sugar.py:348
        refbase = "local_vars->" if is_control_local_var(src.ref.name) else 'parameters.' ## compiler/utils/codegen.sugar.py:349
        generated_code += add_code(' memcpy(&{}, {}({}{}), {});'.format(src_buffer, indirection, refbase, src.ref.name, dst_bytewidth), 349)
    else: ## compiler/utils/codegen.sugar.py:351
        generated_code += add_code(' {} = {};'.format(src_buffer, format_expr(src)), 351)


    generated_code += add_code(' // MODIFY_INT32_INT32_AUTO_PACKET(pd, {}, {}, {})'.format(dst_header_id, dst_field_id, src_buffer), 354)
    generated_code += add_code(' set_field((fldT[]){{{{pd, {}, {}}}}}, 0, {}, {});'.format(dst_header_id, dst_field_id, src_buffer, dst_width), 355)


    return generated_code

def gen_format_statement_fieldref(dst, src): ## compiler/utils/codegen.sugar.py:359
    generated_code = ""
    #TODO: handle preparsed fields, width assignment for vw fields and assignment to buffer instead header fields ## compiler/utils/codegen.sugar.py:360
    dst_width = dst.type.size ## compiler/utils/codegen.sugar.py:361
    dst_is_vw = dst.type.node_type == 'Type_Varbits' ## compiler/utils/codegen.sugar.py:362
    dst_bytewidth = (dst_width+7)/8 ## compiler/utils/codegen.sugar.py:363

    assert(dst_width == src.type.size) ## compiler/utils/codegen.sugar.py:365
    assert(dst_is_vw == (src.type.node_type == 'Type_Varbits')) ## compiler/utils/codegen.sugar.py:366

    dst_name      = dst.expr.member if dst.expr.node_type == 'Member' else dst.expr.path.name if dst.expr('header_ref', lambda h: h.type_ref.is_metadata) else dst.expr._header_ref._path.name ## compiler/utils/codegen.sugar.py:368
    if dst.expr("ref.type.type_ref.is_metadata") and dst.expr.path.name == "meta": ## compiler/utils/codegen.sugar.py:369
        dst_header_id = "header_instance_meta" ## compiler/utils/codegen.sugar.py:370
    elif dst.expr("ref.type.type_ref.is_metadata"): ## compiler/utils/codegen.sugar.py:371
        dst_header_id = "header_instance_all_metadatas" ## compiler/utils/codegen.sugar.py:372
    else: ## compiler/utils/codegen.sugar.py:373
        dst_header_id = 'header_instance_{}'.format(dst_name) ## compiler/utils/codegen.sugar.py:374
    #dst_header_id = "header_instance_all_metadatas" if dst.expr("ref.type.type_ref.is_metadata") else 'header_instance_{}'.format(dst_name) ## compiler/utils/codegen.sugar.py:375
    dst_field_id  = member_to_field_id(dst) ## compiler/utils/codegen.sugar.py:376

    if dst_width <= 32: ## compiler/utils/codegen.sugar.py:378
        generated_code += str( gen_format_statement_fieldref_short(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id)) ## compiler/utils/codegen.sugar.py:378
    else: ## compiler/utils/codegen.sugar.py:380
        generated_code += str( gen_format_statement_fieldref_wide(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id)) ## compiler/utils/codegen.sugar.py:380



    return generated_code

def is_atomic_block(blckstmt): ## compiler/utils/codegen.sugar.py:385
    try: ## compiler/utils/codegen.sugar.py:386
        for annot in blckstmt.annotations.annotations.vec: ## compiler/utils/codegen.sugar.py:387
            if annot.name == "atomic": ## compiler/utils/codegen.sugar.py:388
               return True ## compiler/utils/codegen.sugar.py:389
    except: ## compiler/utils/codegen.sugar.py:390
        return False ## compiler/utils/codegen.sugar.py:391
    return False ## compiler/utils/codegen.sugar.py:392


def gen_do_assignment(dst, src): ## compiler/utils/codegen.sugar.py:395
    generated_code = ""
    if dst.type.node_type == 'Type_Header': ## compiler/utils/codegen.sugar.py:396
        generated_code += add_code(" // TODO make it work properly for non-byte-aligned headers", 396)
        if hasattr(dst, "member"): ## compiler/utils/codegen.sugar.py:398
            if hasattr(src, "member"): ## compiler/utils/codegen.sugar.py:399
                generated_code += add_code(' memcpy(pd->headers[header_instance_{}].pointer, pd->headers[header_instance_{}].pointer, header_instance_byte_width[header_instance_{}]);'.format(dst.member, src.member, src.member), 399)
                generated_code += add_code(' dbg_bytes(pd->headers[header_instance_{}].pointer, header_instance_byte_width[header_instance_{}], "Copied %02d bytes from header_instance_{} to header_instance_{}: ", header_instance_byte_width[header_instance_{}]);'.format(dst.member, src.member, src.member, dst.member, src.member), 400)
            else: ## compiler/utils/codegen.sugar.py:402
                addError("Compiling assignment", "Assigning to header instance {} (type {}) from {} ({}) is not supported".format(dst.member, dst.type.name, src.ref.name, src.type.name)) ## compiler/utils/codegen.sugar.py:403
        else: ## compiler/utils/codegen.sugar.py:404
            addError("Compiling assignment", "Assigning {} (type {}) from {} ({}) is not supported".format(dst.ref.name, dst.type.name, src.ref.name, src.type.name)) ## compiler/utils/codegen.sugar.py:405
    elif dst.type.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:406
        # TODO refine the condition to find out whether to use an assignment or memcpy ## compiler/utils/codegen.sugar.py:407
        requires_memcpy = src.type.size > 32 ## compiler/utils/codegen.sugar.py:408
        is_assignable = src.type.size in range(0,17) ## compiler/utils/codegen.sugar.py:409

        if src.type.node_type == 'Type_Bits' and not requires_memcpy: ## compiler/utils/codegen.sugar.py:411
            if is_assignable: ## compiler/utils/codegen.sugar.py:412
                # TODO how to decide whether src is a pointer, and therefore needs dereferencing? ## compiler/utils/codegen.sugar.py:413
                needs_defererencing = src.node_type not in ["Constant"] ## compiler/utils/codegen.sugar.py:414
                # needs_defererencing = src('field_ref', lambda fr: fr.name == 'meta') ## compiler/utils/codegen.sugar.py:415
                dereference = "*" if needs_defererencing else "" ## compiler/utils/codegen.sugar.py:416

                if dst("expr.ref.type.type_ref.is_metadata"): ## compiler/utils/codegen.sugar.py:418
                    generated_code += add_code(' set_field((fldT[]){{{{pd, header_instance_all_metadatas, field_{}_{}}}}}, 0, ({}({})), {});'.format(dst.expr.ref.type.type_ref.name, dst.member, dereference, format_expr(src, expand_parameters=True), dst.type._type_ref.size), 418)
                    generated_code += add_code(' debug("       : " T4LIT(all_metadatas,header) "." T4LIT({}_{},field) "/" T4LIT(%d) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {}({}), {}({}));'.format(dst.expr.ref.type.type_ref.name, dst.member, (src.type.size+7)/8, dst.type._type_ref.size, dereference, format_expr(src, expand_parameters=True), dereference, format_expr(src, expand_parameters=True)), 419)
                elif dst("header_ref.type.type_ref.is_metadata"): ## compiler/utils/codegen.sugar.py:421
                    generated_code += add_code(' set_field((fldT[]){{{{pd, header_instance_all_metadatas, field_{}_{}}}}}, 0, ({}({})), {});'.format(dst.header_ref.type.type_ref.name, dst.field_name, dereference, format_expr(src, expand_parameters=True), dst.type._type_ref.size), 421)
                    generated_code += add_code(' debug("       : " T4LIT(all_metadatas,header) "." T4LIT({}_{},field) "/" T4LIT(%d) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {}({}), {}({}));'.format(dst.header_ref.type.type_ref.name, dst.field_name, (src.type.size+7)/8, dst.type._type_ref.size, dereference, format_expr(src, expand_parameters=True), dereference, format_expr(src, expand_parameters=True)), 422)
                else: ## compiler/utils/codegen.sugar.py:424
                    if hasattr(src,'method'): ## compiler/utils/codegen.sugar.py:425
                        if src.method.member == "lookahead": ## compiler/utils/codegen.sugar.py:426
                            generated_code += add_code(' {} = {};'.format(format_expr(dst), format_expr(src, expand_parameters=True)), 426)
                        else: ## compiler/utils/codegen.sugar.py:428
                            generated_code += add_code(' {} = ({})(({}));'.format(format_expr(dst), format_type(dst.type), format_expr(src, expand_parameters=True)), 428)
                    if dst.node_type == 'Member': ## compiler/utils/codegen.sugar.py:430
                        if dst.type('is_metadata', lambda ismeta: ismeta): ## compiler/utils/codegen.sugar.py:431
                            # Note: the metadata header and field name is joined by underscores, separating them as best as possible ## compiler/utils/codegen.sugar.py:432
                            nameparts = dst.member.split("_") ## compiler/utils/codegen.sugar.py:433
                            hdr = "_".join(nameparts[1:-1]) ## compiler/utils/codegen.sugar.py:434
                            fld = nameparts[-1] ## compiler/utils/codegen.sugar.py:435
                        else: ## compiler/utils/codegen.sugar.py:436
                            hdr = dst.expr.path.name ## compiler/utils/codegen.sugar.py:437
                            fld = dst.member ## compiler/utils/codegen.sugar.py:438
                        generated_code += add_code(' debug("       : " T4LIT({},header) "." T4LIT({},field) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {});'.format(hdr, fld, (src.type.size+7)/8, format_expr(dst), format_expr(dst)), 438)
                    else: ## compiler/utils/codegen.sugar.py:440
                        generated_code += add_code(' debug("       : " T4LIT({},header) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {});'.format(format_expr(dst, expand_parameters=True), (src.type.size+7)/8, format_expr(dst), format_expr(dst)), 440)
            else: ## compiler/utils/codegen.sugar.py:442
                tmpvar = generate_var_name() ## compiler/utils/codegen.sugar.py:443
                generated_code += add_code(' {} {} = {};'.format(format_type(dst.type), tmpvar, format_expr(src, expand_parameters=True)), 443)
                generated_code += add_code(' {} = {};'.format(format_expr(dst), tmpvar), 444)
                generated_code += add_code(' {} = ({})(({}));'.format(format_expr(dst), format_type(dst.type), format_expr(src, expand_parameters=True)), 445)
                # TODO this part should not require memcpy ## compiler/utils/codegen.sugar.py:447
                # [ ${format_type(dst.type)} $tmpvar = ${format_expr(src, expand_parameters=True)}; ## compiler/utils/codegen.sugar.py:448
                # [ memcpy(&(${format_expr(dst)}), &$tmpvar, sizeof(${format_type(dst.type)})); ## compiler/utils/codegen.sugar.py:449
                # TODO debug printout ## compiler/utils/codegen.sugar.py:450
        else: ## compiler/utils/codegen.sugar.py:451
            generated_code += add_code(' memcpy(&({}), &({}), {});'.format(format_expr(dst), format_expr(src, expand_parameters=True), dst.type.size), 451)
            generated_code += add_code(' dbg_bytes(&({}), {}, "Copied " T4LIT(%02d) " bytes from {} to {}: ", {});'.format(format_expr(src, expand_parameters=True), dst.type.size, format_expr(src, expand_parameters=True), format_expr(dst), dst.type.size), 452)
    else: ## compiler/utils/codegen.sugar.py:454
        generated_code += add_code(' {} = {};'.format(format_expr(dst), format_expr(src, expand_parameters=True)), 454)


    return generated_code

def gen_format_statement(stmt): ## compiler/utils/codegen.sugar.py:458
    generated_code = ""
    global enclosing_control ## compiler/utils/codegen.sugar.py:459
    if stmt.node_type == 'AssignmentStatement': ## compiler/utils/codegen.sugar.py:460
        dst = stmt.left ## compiler/utils/codegen.sugar.py:461
        src = stmt.right ## compiler/utils/codegen.sugar.py:462
        if hasattr(dst, 'field_ref'): ## compiler/utils/codegen.sugar.py:463
            generated_code += str( gen_format_statement_fieldref(dst, src)) ## compiler/utils/codegen.sugar.py:463
        else: ## compiler/utils/codegen.sugar.py:465
            generated_code += str( gen_do_assignment(dst, src)) ## compiler/utils/codegen.sugar.py:465
    elif stmt.node_type == 'BlockStatement': ## compiler/utils/codegen.sugar.py:467
        is_atomic = is_atomic_block(stmt) ## compiler/utils/codegen.sugar.py:468
        if is_atomic: ## compiler/utils/codegen.sugar.py:469
            generated_code += add_code(' LOCK(&{}_lock)'.format(enclosing_control.type.name), 469)
        for c in stmt.components: ## compiler/utils/codegen.sugar.py:471
            generated_code += str( gen_format_statement(c)) ## compiler/utils/codegen.sugar.py:471
        if is_atomic: ## compiler/utils/codegen.sugar.py:473
            generated_code += add_code(' UNLOCK(&{}_lock)'.format(enclosing_control.type.name), 473)
    elif stmt.node_type == 'IfStatement': ## compiler/utils/codegen.sugar.py:475
        t = format_statement(stmt.ifTrue) if hasattr(stmt, 'ifTrue') else ';' ## compiler/utils/codegen.sugar.py:476
        f = format_statement(stmt.ifFalse) if hasattr(stmt, 'ifFalse') else ';' ## compiler/utils/codegen.sugar.py:477
        cond = format_expr(stmt.condition) ## compiler/utils/codegen.sugar.py:478

        # TODO this happens when .hit() is called; make a proper solution ## compiler/utils/codegen.sugar.py:480
        if cond.strip() == '': ## compiler/utils/codegen.sugar.py:481
            cond = "true" ## compiler/utils/codegen.sugar.py:482

        generated_code += add_code(' if( {} ) {{'.format(cond), 483)
        generated_code += add_code('     {}'.format(t), 484)
        generated_code += add_code("", 485)
        generated_code += add_code(" } else {", 486)
        generated_code += add_code('     {}'.format(f), 487)
        generated_code += add_code(" }", 488)
    elif stmt.node_type == 'MethodCallStatement': ## compiler/utils/codegen.sugar.py:490
        m = stmt.methodCall.method ## compiler/utils/codegen.sugar.py:491

        if m.node_type == 'Method' and m.name == 'digest': ## compiler/utils/codegen.sugar.py:493
            return gen_format_methodcall_digest(stmt, m) ## compiler/utils/codegen.sugar.py:494
        else: ## compiler/utils/codegen.sugar.py:495
            if m.get_attr('member') is not None: ## compiler/utils/codegen.sugar.py:496
                return gen_format_expr_methodcall(stmt, m) ## compiler/utils/codegen.sugar.py:497
            else: ## compiler/utils/codegen.sugar.py:498
                generated_code += str( gen_methodcall(stmt)) ## compiler/utils/codegen.sugar.py:498
    elif stmt.node_type == 'SwitchStatement': ## compiler/utils/codegen.sugar.py:500
        generated_code += add_code(' switch({}) {{'.format(format_expr(stmt.expression)), 500)
        for case in stmt.cases: ## compiler/utils/codegen.sugar.py:502
            if case.label.node_type == "DefaultExpression": ## compiler/utils/codegen.sugar.py:503
                generated_code += add_code(" default:", 503)
            else: ## compiler/utils/codegen.sugar.py:505
                generated_code += add_code(' case {}:'.format(format_expr(case.label)), 505)
            generated_code += add_code('   {}'.format(format_statement(case.statement)), 506)
            generated_code += add_code("   break;", 507)
        if [case for case in stmt.cases if case.label.node_type == "DefaultExpression"] == []: ## compiler/utils/codegen.sugar.py:509
            generated_code += add_code("   default: {}", 509)
        generated_code += add_code(" }", 510)

    return generated_code

def gen_format_methodcall_digest(stmt, m): ## compiler/utils/codegen.sugar.py:513
    generated_code = ""
    digest_name = stmt.methodCall.typeArguments[0].name ## compiler/utils/codegen.sugar.py:514
    port, fields = stmt.methodCall.arguments ## compiler/utils/codegen.sugar.py:515

    generated_code += add_code(" struct type_field_list fields;", 516)
    generated_code += add_code(' fields.fields_quantity = {};'.format(len(fields)), 517)
    generated_code += add_code(" fields.field_offsets = malloc(sizeof(uint8_t*)*fields.fields_quantity);", 518)
    generated_code += add_code(" fields.field_widths = malloc(sizeof(uint8_t*)*fields.fields_quantity);", 519)

    for idx, f in enumerate(fields.components): ## compiler/utils/codegen.sugar.py:522
        if f.expr.type.is_metadata: ## compiler/utils/codegen.sugar.py:523
            generated_code += add_code(' fields.field_offsets[{}] = (uint8_t*) field_desc(pd, field_instance_{}_{}).byte_addr;'.format(idx, f.expr.name, f.member), 523)
            generated_code += add_code(' fields.field_widths[{}]  =            field_desc(pd, field_instance_{}_{}).bitwidth;'.format(idx, f.expr.name, f.member), 524)
        else: ## compiler/utils/codegen.sugar.py:526
            generated_code += add_code(' fields.field_offsets[{}] = (uint8_t*) field_desc(pd, field_instance_{}_{}).byte_addr;'.format(idx, f.expr.member, f.expression.field_ref.name), 526)
            generated_code += add_code(' fields.field_widths[{}]  =            field_desc(pd, field_instance_{}_{}).bitwidth;'.format(idx, f.expr.member, f.expression.field_ref.name), 527)
    generated_code += add_code(' generate_digest(bg,"{}",0,&fields);'.format(digest_name), 528)
    generated_code += add_code(" sleep_millis(DIGEST_SLEEP_MILLIS);", 529)

    return generated_code

def is_emit(stmt, m): ## compiler/utils/codegen.sugar.py:532
    return m.expr._ref('type')._type_ref('name', lambda n: n == 'packet_out') ## compiler/utils/codegen.sugar.py:533

def gen_format_expr_methodcall(stmt, m): ## compiler/utils/codegen.sugar.py:535
    generated_code = ""
    if is_emit(stmt, m): ## compiler/utils/codegen.sugar.py:536
        arg = stmt.methodCall.arguments[0] ## compiler/utils/codegen.sugar.py:537
        hdr = arg.expression.member ## compiler/utils/codegen.sugar.py:538
        hdr_type = arg.expression.type ## compiler/utils/codegen.sugar.py:539

        hdr_name = arg.expression.header_ref.name if hasattr(arg.expression, 'header_ref') else arg.expression.member ## compiler/utils/codegen.sugar.py:541

        generated_code += add_code(' pd->header_reorder[pd->emit_hdrinst_count] = header_instance_{};'.format(hdr), 542)
        generated_code += add_code(" ++pd->emit_hdrinst_count;", 543)
    elif (m.expr.node_type, m.expr('ref').node_type, m.member) == ('PathExpression', 'P4Table', 'apply'): ## compiler/utils/codegen.sugar.py:545
        generated_code += add_code(' {};'.format(gen_method_apply(stmt.methodCall)), 545)
    elif m.expr.get_attr('member') is None: ## compiler/utils/codegen.sugar.py:547
        return gen_format_expr_methodcall_extern(stmt, m) ## compiler/utils/codegen.sugar.py:548
    else: ## compiler/utils/codegen.sugar.py:549
        hdr_name = m.expr.member ## compiler/utils/codegen.sugar.py:550

        if m.member == 'isValid': ## compiler/utils/codegen.sugar.py:552
            generated_code += add_code(' controlLocal_tmp_0 = (pd->headers[header_instance_{}].pointer != NULL);'.format(hdr_name), 552)
        elif m.member == 'setValid': ## compiler/utils/codegen.sugar.py:554
            generated_code += add_code(' if (likely(pd->headers[header_instance_{}].pointer == NULL)) {{'.format(hdr_name), 554)
            generated_code += add_code('    pd->headers[header_instance_{}].pointer = (pd->header_tmp_storage + header_instance_infos[header_instance_{}].byte_offset);'.format(hdr_name, hdr_name), 555)
            generated_code += add_code("    pd->is_emit_reordering = true;", 556)
            generated_code += add_code('    debug("   :: Header instance " T4LIT({},header) "/" T4LIT(%d) "B set as " T4LIT(valid,success) "\\n", pd->headers[header_instance_{}].length);'.format(hdr_name, hdr_name), 557)
            generated_code += add_code(" } else {", 558)
            generated_code += add_code('    debug("   " T4LIT(!!,warning) " Trying to set header instance " T4LIT({},header) " to " T4LIT(valid,success) ", but it is already " T4LIT(valid,success) "\\n");'.format(hdr_name), 559)
            generated_code += add_code(" }", 560)
        elif m.member == 'setInvalid': ## compiler/utils/codegen.sugar.py:562
            generated_code += add_code(' if (likely(pd->headers[header_instance_{}].pointer != NULL)) {{'.format(hdr_name), 562)
            generated_code += add_code('    pd->headers[header_instance_{}].pointer = NULL;'.format(hdr_name), 563)
            generated_code += add_code("    pd->is_emit_reordering = true;", 564)
            generated_code += add_code('    debug("   :: Header instance " T4LIT({},header) "/" T4LIT(%d) "B set as " T4LIT(invalid,status) "\\n", pd->headers[header_instance_{}].length);'.format(hdr_name, hdr_name), 565)
            generated_code += add_code(" } else {", 566)
            generated_code += add_code('    debug("   " T4LIT(!!,warning) " Trying to set header instance " T4LIT({},header) " to " T4LIT(valid,success) ", but it is already " T4LIT(valid,success) "\\n");'.format(hdr_name), 567)
            generated_code += add_code(" }", 568)
        else: ## compiler/utils/codegen.sugar.py:570
            generated_code += str( gen_methodcall(stmt)) ## compiler/utils/codegen.sugar.py:570

    return generated_code

def gen_format_expr_methodcall_extern(stmt, m): ## compiler/utils/codegen.sugar.py:573
    generated_code = ""
    smem_type = m.expr.type._baseType.name ## compiler/utils/codegen.sugar.py:574

    # if the extern is about both packets and bytes, it takes two separate calls ## compiler/utils/codegen.sugar.py:576
    is_possibly_multiple = smem_type in ["counter", "meter", "direct_counter", "direct_meter"] ## compiler/utils/codegen.sugar.py:577
    if is_possibly_multiple: ## compiler/utils/codegen.sugar.py:578
        if m.expr.ref.packets_or_bytes == "packets_and_bytes": ## compiler/utils/codegen.sugar.py:579
            generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, "packets")) ## compiler/utils/codegen.sugar.py:579
            generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, "bytes")) ## compiler/utils/codegen.sugar.py:580
        else: ## compiler/utils/codegen.sugar.py:582
            generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, m.expr.ref.packets_or_bytes)) ## compiler/utils/codegen.sugar.py:582
    else: ## compiler/utils/codegen.sugar.py:584
        generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple)) ## compiler/utils/codegen.sugar.py:584


    return generated_code

def gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, packets_or_bytes = None): ## compiler/utils/codegen.sugar.py:588
    generated_code = ""
    mexpr_type = m.expr.type ## compiler/utils/codegen.sugar.py:589

    if m.expr.type.node_type == "Type_SpecializedCanonical": ## compiler/utils/codegen.sugar.py:591
        mexpr_type = mexpr_type.substituted ## compiler/utils/codegen.sugar.py:592
    parameters = stmt.methodCall.method.type.parameters.parameters ## compiler/utils/codegen.sugar.py:593
    method_args = zip(stmt.methodCall.arguments, parameters) ## compiler/utils/codegen.sugar.py:594
    mprefix = "global_smem." ## compiler/utils/codegen.sugar.py:595
    mname = mprefix + m.expr.path.name ## compiler/utils/codegen.sugar.py:596
    mparname = mname ## compiler/utils/codegen.sugar.py:597

    if smem_type in ["counter", "meter"]: ## compiler/utils/codegen.sugar.py:599
        mname = "{}{}_{}_{}".format(mprefix, smem_type, m.expr.path.name, packets_or_bytes) ## compiler/utils/codegen.sugar.py:600
        mparname = mname ## compiler/utils/codegen.sugar.py:601
    if smem_type in ["direct_counter", "direct_meter"]: ## compiler/utils/codegen.sugar.py:602
        mname = "{}{}_{}_{}_{}".format(mprefix, smem_type, m.expr.path.name, packets_or_bytes, "TODO_table") ## compiler/utils/codegen.sugar.py:603
        mparname = mname ## compiler/utils/codegen.sugar.py:604
    packets_or_bytes_override = None ## compiler/utils/codegen.sugar.py:605
    if method_args != []: ## compiler/utils/codegen.sugar.py:606
        (expr, par) = method_args[0] ## compiler/utils/codegen.sugar.py:607
        if m.expr.ref._packets_or_bytes == "packets_and_bytes": ## compiler/utils/codegen.sugar.py:608
            packets_or_bytes_override = packets_or_bytes ## compiler/utils/codegen.sugar.py:609
    if m.expr.type.node_type == "Type_Extern": ## compiler/utils/codegen.sugar.py:610
        # TODO support parameters of type Type_List (e.g. in InternetChecksum in the example psa-l3fwd-with-chksm) ## compiler/utils/codegen.sugar.py:611
        stypename = stmt.methodCall.method.expr.type.name ## compiler/utils/codegen.sugar.py:612
        paramtypes = ['{}_t*'.format(stypename) if idx == 0 else gen_format_type(arg[0].expression.type) for idx, arg in enumerate(method_args)] ## compiler/utils/codegen.sugar.py:613
    elif m.expr.type.node_type == "Type_SpecializedCanonical": ## compiler/utils/codegen.sugar.py:614
        method_args = method_args[1:] ## compiler/utils/codegen.sugar.py:615

        if hasattr(expr.expression, 'name'): ## compiler/utils/codegen.sugar.py:617
            paramtype = "struct " + expr.expression.name ## compiler/utils/codegen.sugar.py:618
        elif expr.expression.type.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:619
            paramtype = format_type(expr.expression.type) ## compiler/utils/codegen.sugar.py:620
        elif expr.expression.node_type == 'Constant': ## compiler/utils/codegen.sugar.py:621
            paramtype = format_type(expr.expression.type) ## compiler/utils/codegen.sugar.py:622
        elif m.expr.ref.type.baseType.type_ref.node_type == 'Type_Extern': ## compiler/utils/codegen.sugar.py:623
            paramtype = m.expr.type.arguments[0].name ## compiler/utils/codegen.sugar.py:624
        else: ## compiler/utils/codegen.sugar.py:625
            paramtype = "int/*temporarily inserted for unknown type*/" ## compiler/utils/codegen.sugar.py:626
            addWarning('generating method call statement', 'Unexpected type {} in {}'.format(m.expr.type, stmt.methodCall)) ## compiler/utils/codegen.sugar.py:627

        if is_possibly_multiple and hasattr(expr.expression.type, 'fields'): ## compiler/utils/codegen.sugar.py:629
            tmpvar = generate_var_name() ## compiler/utils/codegen.sugar.py:630
            generated_code += add_code(' {} {} = {};'.format(paramtype, tmpvar, gen_extern_format_parameter(expr, par, packets_or_bytes_override)), 630)

            for fld, component in zip(expr.expression.type.fields, stmt.methodCall.arguments[0].expression.components): ## compiler/utils/codegen.sugar.py:633
                ce = component.expression ## compiler/utils/codegen.sugar.py:634

                if fld.type.size <= 32: ## compiler/utils/codegen.sugar.py:636
                    generated_code += add_code(' dbg_bytes(&({}.{}), ({}+7)/8, "       : " T4LIT({},header) "." T4LIT({},field) " = ");'.format(tmpvar, fld.name, fld.type.size, format_expr(ce.expr), ce.member), 636)
                    continue ## compiler/utils/codegen.sugar.py:638

                hdr = ce.expr.header_ref.name ## compiler/utils/codegen.sugar.py:640

                generated_code += add_code(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, field_instance_{}_{}, &({}.{}));'.format(hdr, hdr, ce.field_ref.name, tmpvar, fld.name), 641)
                generated_code += add_code(' dbg_bytes(&({}.{}), ({}+7)/8, "       : " T4LIT({},header) "." T4LIT({},field) " = ");'.format(tmpvar, fld.name, fld.type.size, hdr, ce.field_ref.name), 642)

            generated_code += add_code(' memcpy(&({}), &{}, sizeof({}));'.format(mname, tmpvar, paramtype), 644)
        paramtypes = [paramtype] ## compiler/utils/codegen.sugar.py:646
    def resolve_type(t, type_params): ## compiler/utils/codegen.sugar.py:647
        return type_params[t.name] if t.node_type == 'Type_Var' else t ## compiler/utils/codegen.sugar.py:648

    extern_param_indexes = { ## compiler/utils/codegen.sugar.py:650
        ('meter',        'execute_meter'): ([1]), ## compiler/utils/codegen.sugar.py:651
        ('register',     'read'):          ([0]), ## compiler/utils/codegen.sugar.py:652
        ('register',     'write'):         ([1]), ## compiler/utils/codegen.sugar.py:653
        ('Digest',       'pack'):          ([0]), ## compiler/utils/codegen.sugar.py:654
    } ## compiler/utils/codegen.sugar.py:655

    base_type = m.expr.ref.type ## compiler/utils/codegen.sugar.py:657
    if hasattr(base_type, 'baseType'): ## compiler/utils/codegen.sugar.py:658
        base_type = base_type.baseType ## compiler/utils/codegen.sugar.py:659

    extern_type = base_type.type_ref.name ## compiler/utils/codegen.sugar.py:661

    type_param_names = [t.name for t in stmt.methodCall.method.type.typeParameters.parameters] ## compiler/utils/codegen.sugar.py:663
    type_params = dict(zip(type_param_names, stmt.methodCall.typeArguments)) ## compiler/utils/codegen.sugar.py:664
    param_indexes = extern_param_indexes[(extern_type, m.member)] if (extern_type, m.member) in extern_param_indexes else [] ## compiler/utils/codegen.sugar.py:665
    types = [m.type.parameters.parameters[par].type for par in param_indexes] ## compiler/utils/codegen.sugar.py:666

    # the indexes of the parameters which originate from a type parameter ## compiler/utils/codegen.sugar.py:668
    # TODO generalize and move to hlir16_attrs ## compiler/utils/codegen.sugar.py:669
    default_extern_opts = (True, [], None, None) ## compiler/utils/codegen.sugar.py:670
    # TODO add a way to issue compile time/runtime warnings (addWarning), e.g. if there is a buffer overflow ## compiler/utils/codegen.sugar.py:671

    externs = { ## compiler/utils/codegen.sugar.py:673
        ('bytes',   'meter',        'execute_meter'): ( True, [],        ["{0}", "{2}", "{3}"],            ["{0}[(uint32_t)({1}) - 1]", "*((uint32_t*)({2}))"]), ## compiler/utils/codegen.sugar.py:674
        ('packets', 'counter',      'count'):         ( True, [],        ["{0}", "int", "uint32_t"],       ["{0}[(uint32_t)({1}) - 1]", "{1}", "1"]), ## compiler/utils/codegen.sugar.py:675
        ('bytes',   'counter',      'count'):         ( True, [],        ["{0}", "int", "uint32_t"],       ["REPLACED_BELOW"]), ## compiler/utils/codegen.sugar.py:676
        (None,      'register',     'read'):          ( True, ["&({})"], ["register_{0}*", "{1}*", "{2}"], None), ## compiler/utils/codegen.sugar.py:677
        (None,      'register',     'write'):         ( True, ["{}"],    ["register_{0}*", "int", "{2}"],  ["{0}", "(int)({1})", "{2}"]), ## compiler/utils/codegen.sugar.py:678
        (None,      'Digest',       'pack'):          (False, [],        ["{1}*"],                         None), ## compiler/utils/codegen.sugar.py:679
    } ## compiler/utils/codegen.sugar.py:680

    extern_params = (packets_or_bytes, extern_type, m.member) ## compiler/utils/codegen.sugar.py:682
    type_args_in_fun_name, expr_args, type_par_reformat, arg_reformat = externs[extern_params] if extern_params in externs else default_extern_opts ## compiler/utils/codegen.sugar.py:683

    if packets_or_bytes == 'bytes': ## compiler/utils/codegen.sugar.py:685
        varname = generate_var_name("packet_size_bytes"); ## compiler/utils/codegen.sugar.py:686
        prepend_statement(' uint32_t {} = pd->parsed_length; // (prepended) compiler/utils/codegen.sugar.py:686\n'.format(varname)) ## compiler/utils/codegen.sugar.py:687
        arg_reformat = ["{0}[(uint32_t)({1}) - 1]", "{1}", varname] ## compiler/utils/codegen.sugar.py:688

    type_params2 = paramtypes + [format_type(resolve_type(par.type, type_params)) for par in parameters] ## compiler/utils/codegen.sugar.py:690
    if type_par_reformat is not None: ## compiler/utils/codegen.sugar.py:691
        type_params2 = [fmt.format(*type_params2) for fmt in type_par_reformat] ## compiler/utils/codegen.sugar.py:692
    if type_params2[2]=="uint16_t" and type_params2[0]=='register_uint32_t*': ## compiler/utils/codegen.sugar.py:693
        type_params2[0]='register_uint16_t*' ## compiler/utils/codegen.sugar.py:694
    if type_params2[2]=="uint8_t" and type_params2[0]=='register_uint32_t*': ## compiler/utils/codegen.sugar.py:695
        type_params2[0] = 'register_uint8_t*' ## compiler/utils/codegen.sugar.py:696
    type_params_str = ", ".join(type_params2) ## compiler/utils/codegen.sugar.py:697
    (a, par) = method_args[0] ## compiler/utils/codegen.sugar.py:698
    if expr_args != []: ## compiler/utils/codegen.sugar.py:699
        ee = expr.expression ## compiler/utils/codegen.sugar.py:700
        # TODO if 'meta', use the appropriate field of all_metadatas ## compiler/utils/codegen.sugar.py:701

        if ee.node_type == "Constant": ## compiler/utils/codegen.sugar.py:703
            local_name = str(0) ## compiler/utils/codegen.sugar.py:704
        else: ## compiler/utils/codegen.sugar.py:705
            c=ee._expr ## compiler/utils/codegen.sugar.py:706

            try: ## compiler/utils/codegen.sugar.py:708
                if ee._expr.path.name == 'meta': ## compiler/utils/codegen.sugar.py:709
                    local_name = mprefix + ee.member ## compiler/utils/codegen.sugar.py:710
                    if(re.match("isInPIT",ee.member)): ## compiler/utils/codegen.sugar.py:711
                        if (type_params2[2] == "uint32_t"): ## compiler/utils/codegen.sugar.py:712
                            generated_code += add_code(' uint32_t* tmp{}= (uint32_t*)malloc(32*sizeof(uint32_t));'.format(ee.member), 712)
                        elif(type_params2[2] == "uint16_t"): ## compiler/utils/codegen.sugar.py:714
                            generated_code += add_code(' uint16_t* tmp{}= (uint16_t*)malloc(16*sizeof(uint16_t));'.format(ee.member), 714)
                        local_name = "tmp" + ee.member ## compiler/utils/codegen.sugar.py:716
                        expr_args[0] = "{}" ## compiler/utils/codegen.sugar.py:717
                    if(re.match("name_hash",ee.member)): ## compiler/utils/codegen.sugar.py:718
                        if (type_params2[2] == "uint32_t"): ## compiler/utils/codegen.sugar.py:719
                            generated_code += add_code(' uint32_t* tmp{}= (uint32_t*)malloc(32*sizeof(uint32_t));'.format(ee.member), 719)
                        elif(type_params2[2] == "uint16_t"): ## compiler/utils/codegen.sugar.py:721
                            generated_code += add_code(' uint16_t* tmp{}= (uint16_t*)malloc(16*sizeof(uint16_t));'.format(ee.member), 721)
                        local_name = "tmp" + ee.member ## compiler/utils/codegen.sugar.py:723
                        expr_args[0] = "{}" ## compiler/utils/codegen.sugar.py:724
                    if(re.match("isInCS",ee.member)): ## compiler/utils/codegen.sugar.py:725
                        if (type_params2[2] == "uint32_t"): ## compiler/utils/codegen.sugar.py:726
                            generated_code += add_code(' uint32_t* tmp{}= (uint32_t*)malloc(32*sizeof(uint32_t));'.format(ee.member), 726)
                        elif(type_params2[2] == "uint16_t"): ## compiler/utils/codegen.sugar.py:728
                            generated_code += add_code(' uint16_t* tmp{}= (uint16_t*)malloc(16*sizeof(uint16_t));'.format(ee.member), 728)
                        local_name = "tmp" + ee.member ## compiler/utils/codegen.sugar.py:730
                        expr_args[0] = "{}" ## compiler/utils/codegen.sugar.py:731
                        expr_args[0] = "{}" ## compiler/utils/codegen.sugar.py:732
                    if(re.match("pkg_number",ee.member)): ## compiler/utils/codegen.sugar.py:733
                        if (type_params2[2] == "uint32_t"): ## compiler/utils/codegen.sugar.py:734
                            generated_code += add_code(' uint32_t* tmp{}= (uint32_t*)malloc(32*sizeof(uint32_t));'.format(ee.member), 734)
                        elif(type_params2[2] == "uint16_t"): ## compiler/utils/codegen.sugar.py:736
                            generated_code += add_code(' uint16_t* tmp{}= (uint16_t*)malloc(16*sizeof(uint16_t));'.format(ee.member), 736)
                        local_name = "tmp" + ee.member ## compiler/utils/codegen.sugar.py:738
                        expr_args[0] = "{}" ## compiler/utils/codegen.sugar.py:739
                else: ## compiler/utils/codegen.sugar.py:740
                    local_name = mprefix + ee.expr.path.name ## compiler/utils/codegen.sugar.py:741
                    if(re.match("standard_metadata",ee.expr.path.name)): ## compiler/utils/codegen.sugar.py:742
                        if (type_params2[2] == "uint32_t"): ## compiler/utils/codegen.sugar.py:743
                            generated_code += add_code(' uint32_t* tmp{}= (uint32_t*)malloc(32*sizeof(uint32_t));'.format(ee.expr.path.name), 743)
                        elif(type_params2[2] == "uint16_t"): ## compiler/utils/codegen.sugar.py:745
                            generated_code += add_code(' uint16_t* tmp{}= (uint16_t*)malloc(16*sizeof(uint16_t));'.format(ee.expr.path.name), 745)
                        local_name = "tmp" + ee.expr.path.name ## compiler/utils/codegen.sugar.py:747
                        expr_args[0] = "{}" ## compiler/utils/codegen.sugar.py:748
            except: ## compiler/utils/codegen.sugar.py:749
                try: ## compiler/utils/codegen.sugar.py:750
                    if ee._expr.path.name == 'meta': ## compiler/utils/codegen.sugar.py:751
                        local_name = mprefix + ee.member ## compiler/utils/codegen.sugar.py:752
                    else: ## compiler/utils/codegen.sugar.py:753
                        local_name = mprefix + ee.path.name ## compiler/utils/codegen.sugar.py:754
                except: ## compiler/utils/codegen.sugar.py:755
                    local_name = gen_extern_format_parameter(c,par) ## compiler/utils/codegen.sugar.py:756
        # local_name = str(ee.value) if ee.node_type == "Constant" else mprefix + ee.member if ee._expr.path.name == 'meta' else mprefix + ee.path.name ## compiler/utils/codegen.sugar.py:757
        expr_args = [earg.format(local_name) for earg in expr_args] ## compiler/utils/codegen.sugar.py:758



    type_args = "".join(["_" + format_type(resolve_type(t, type_params)) for t in types]) ## compiler/utils/codegen.sugar.py:762

    with SugarStyle("inline_comment"): ## compiler/utils/codegen.sugar.py:764
        param_args = [gen_extern_format_parameter(arg.expression, par) for (arg, par) in method_args] ## compiler/utils/codegen.sugar.py:765
    all_args = [mparname] + expr_args + param_args ## compiler/utils/codegen.sugar.py:766
    if arg_reformat is not None: ## compiler/utils/codegen.sugar.py:767
        all_args = [fmt.format(*all_args) for fmt in arg_reformat] ## compiler/utils/codegen.sugar.py:768
    for all_arg in all_args:  ## compiler/utils/codegen.sugar.py:769
        if(re.match("pkg_number",all_arg)): ## compiler/utils/codegen.sugar.py:770
            all_arg = "*({})".format(all_arg) ## compiler/utils/codegen.sugar.py:771
        

    all_args = ["({})".format(all_args[0])] + all_args[1:] ## compiler/utils/codegen.sugar.py:774
    all_args = ", ".join(all_args) ## compiler/utils/codegen.sugar.py:775
    funname_postfix = type_args if type_args_in_fun_name else "" ## compiler/utils/codegen.sugar.py:776
    prepend_statement(' extern void extern_{}_{}{}({}); // (prepended) compiler/utils/codegen.sugar.py:776\n'.format(mexpr_type.name, m.member, funname_postfix, type_params_str)) ## compiler/utils/codegen.sugar.py:777
    generated_code += add_code(' extern_{}_{}{}({});'.format(mexpr_type.name, m.member, funname_postfix, all_args), 777)
    if expr_args != []: ## compiler/utils/codegen.sugar.py:779
        ee = expr.expression ## compiler/utils/codegen.sugar.py:780
        # TODO if 'meta', use the appropriate field of all_metadatas ## compiler/utils/codegen.sugar.py:781

        if not ee.node_type == "Constant": ## compiler/utils/codegen.sugar.py:783
            try: ## compiler/utils/codegen.sugar.py:784
                if ee._expr.path.name == 'meta': ## compiler/utils/codegen.sugar.py:785
                    if(re.match("isInPIT",ee.member)): ## compiler/utils/codegen.sugar.py:786
                        generated_code += add_code(' MODIFY_INT32_INT32_AUTO_PACKET(pd, header_instance_meta, field_metadata_{}, *tmp{});'.format(ee.member, ee.member), 786)
                    if(re.match("name_hash",ee.member)): ## compiler/utils/codegen.sugar.py:788
                        generated_code += add_code(' MODIFY_INT32_INT32_AUTO_PACKET(pd, header_instance_meta, field_metadata_{}, *tmp{});'.format(ee.member, ee.member), 788)
                    if(re.match("isInCS",ee.member)): ## compiler/utils/codegen.sugar.py:790
                        generated_code += add_code(' MODIFY_INT32_INT32_AUTO_PACKET(pd, header_instance_meta, field_metadata_{}, *tmp{});'.format(ee.member, ee.member), 790)
                    if(re.match("pkg_number",ee.member)): ## compiler/utils/codegen.sugar.py:792
                        generated_code += add_code(' MODIFY_INT32_INT32_AUTO_PACKET(pd, header_instance_meta, field_metadata_{}, *tmp{});'.format(ee.member, ee.member), 792)
                else: ## compiler/utils/codegen.sugar.py:794
                    local_name = ee.expr.path.name ## compiler/utils/codegen.sugar.py:795
                    if(re.match("standard_metadata",ee.expr.path.name)): ## compiler/utils/codegen.sugar.py:796
                        generated_code += add_code(' MODIFY_INT32_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_{}_t_{}, *tmp{});'.format(ee.expr.path.name, ee.member, ee.expr.path.name), 796)
            except: ## compiler/utils/codegen.sugar.py:798
                pass ## compiler/utils/codegen.sugar.py:799


    return generated_code

def gen_methodcall(stmt): ## compiler/utils/codegen.sugar.py:802
    generated_code = ""
    mcall = format_expr(stmt.methodCall) ## compiler/utils/codegen.sugar.py:803

    if mcall: ## compiler/utils/codegen.sugar.py:805
        generated_code += add_code(' {};'.format(mcall), 805)
    else: ## compiler/utils/codegen.sugar.py:807
        addWarning('generating method call statement', 'Invalid method call {}'.format(stmt.methodCall)) ## compiler/utils/codegen.sugar.py:808
        generated_code += add_code(' /* unhandled method call {} */'.format(stmt.methodCall), 808)


    return generated_code

################################################################################ ## compiler/utils/codegen.sugar.py:812

def resolve_reference(e): ## compiler/utils/codegen.sugar.py:814
    if hasattr(e, 'field_ref'): ## compiler/utils/codegen.sugar.py:815
        h = e.expr.header_ref ## compiler/utils/codegen.sugar.py:816
        f = e.field_ref ## compiler/utils/codegen.sugar.py:817
        return (h, f) ## compiler/utils/codegen.sugar.py:818
    else: ## compiler/utils/codegen.sugar.py:819
        return e ## compiler/utils/codegen.sugar.py:820

def is_subsequent((h1,f1), (h2, f2)): ## compiler/utils/codegen.sugar.py:822
    if hasattr(h1, 'type'): ## compiler/utils/codegen.sugar.py:823
        fs = h1.type.type_ref.fields.vec ## compiler/utils/codegen.sugar.py:824
    else: ## compiler/utils/codegen.sugar.py:825
        fs = h1.type_ref.field.vec ## compiler/utils/codegen.sugar.py:826
    return h1 == h2 and fs.index(f1) + 1 == fs.index(f2) ## compiler/utils/codegen.sugar.py:827

def groupby(xs, fun): ## compiler/utils/codegen.sugar.py:829
    """Groups the elements of a list. ## compiler/utils/codegen.sugar.py:830
    The upcoming element will be grouped if ## compiler/utils/codegen.sugar.py:831
    fun(last element of the group, upcoming) evaluates to true.""" ## compiler/utils/codegen.sugar.py:832
    if not xs: ## compiler/utils/codegen.sugar.py:833
        yield [] ## compiler/utils/codegen.sugar.py:834
        return ## compiler/utils/codegen.sugar.py:835

    elems = [] ## compiler/utils/codegen.sugar.py:837
    for x in xs: ## compiler/utils/codegen.sugar.py:838
        if elems == []: ## compiler/utils/codegen.sugar.py:839
            elems = [x] ## compiler/utils/codegen.sugar.py:840
        elif not fun(elems[-1], x): ## compiler/utils/codegen.sugar.py:841
            yield elems ## compiler/utils/codegen.sugar.py:842
            elems = [x] ## compiler/utils/codegen.sugar.py:843
        else: ## compiler/utils/codegen.sugar.py:844
            elems.append(x) ## compiler/utils/codegen.sugar.py:845

    if elems != []: ## compiler/utils/codegen.sugar.py:847
        yield elems ## compiler/utils/codegen.sugar.py:848

def group_references(refs): ## compiler/utils/codegen.sugar.py:850
    for xs in groupby(refs, lambda x1, x2: isinstance(x1, tuple) and isinstance(x2, tuple) and is_subsequent(x1, x2)): ## compiler/utils/codegen.sugar.py:851
        if xs == [None]: ## compiler/utils/codegen.sugar.py:852
            # TODO investigate this case further ## compiler/utils/codegen.sugar.py:853
            continue ## compiler/utils/codegen.sugar.py:854
        
        yield (xs[0][0], map(lambda (hdr, fld): fld, xs)) ## compiler/utils/codegen.sugar.py:856

def fldid(h, f): ## compiler/utils/codegen.sugar.py:858
    inst_type_name = 'all_metadatas' if h._type._type_ref.is_metadata else h.ref.name if h.node_type == 'PathExpression' else h.name ## compiler/utils/codegen.sugar.py:859
    return 'field_instance_{}_{}'.format(inst_type_name, f.name) ## compiler/utils/codegen.sugar.py:860
def fldid2(h, f): return h.id + ',' +  f.id ## compiler/utils/codegen.sugar.py:861


# A set of expression IDs that have already been generated. ## compiler/utils/codegen.sugar.py:864
generated_exprs = set() ## compiler/utils/codegen.sugar.py:865

def convert_component(component): ## compiler/utils/codegen.sugar.py:867
    if component.node_type == 'Member': ## compiler/utils/codegen.sugar.py:868
        hdr      = component.expr ## compiler/utils/codegen.sugar.py:869
        fld_name = component.member ## compiler/utils/codegen.sugar.py:870
        fld      = hdr.type.fields.get(fld_name) ## compiler/utils/codegen.sugar.py:871
        return (component.node_type, hdr, fld) ## compiler/utils/codegen.sugar.py:872

    if component.node_type == 'Constant': ## compiler/utils/codegen.sugar.py:874
        return (component.node_type, component.value, "") ## compiler/utils/codegen.sugar.py:875

    addWarning('generating list expression buffer', 'Skipping not supported list element %s' % component) ## compiler/utils/codegen.sugar.py:877
    return None ## compiler/utils/codegen.sugar.py:878

def listexpression_to_buf(expr): ## compiler/utils/codegen.sugar.py:880
    def width(hdr, fld): ## compiler/utils/codegen.sugar.py:881
        if fld.is_vw: return 'field_desc(pd, %s).bitwidth'%fldid(hdr, fld) ## compiler/utils/codegen.sugar.py:882
        return str(fld.size) ## compiler/utils/codegen.sugar.py:883

    s = "" ## compiler/utils/codegen.sugar.py:885
    o = '0' ## compiler/utils/codegen.sugar.py:886
    # TODO add support for component.node_type == 'Constant' ## compiler/utils/codegen.sugar.py:887
    components = [('tuple', c[0], c[1]) if type(c) == tuple else convert_component(c) for c in map(resolve_reference, expr.components)] ## compiler/utils/codegen.sugar.py:888
    components = [(c[1], c[2]) for c in components if c is not None if c[0] != 'Constant'] ## compiler/utils/codegen.sugar.py:889
    for h, fs in group_references(components): ## compiler/utils/codegen.sugar.py:890
        w = '+'.join([width(h, f) for f in fs]) ## compiler/utils/codegen.sugar.py:891
        s += 'memcpy(buffer%s + (%s+7)/8, field_desc(pd, %s).byte_addr, (%s+7)/8);\n' % (expr.id, o, fldid(h, fs[0]), w) ## compiler/utils/codegen.sugar.py:892
        o += '+'+w ## compiler/utils/codegen.sugar.py:893
    return 'int buffer{0}_size = ({1}+7)/8;\nuint8_t buffer{0}[buffer{0}_size];\n'.format(expr.id, o) + s ## compiler/utils/codegen.sugar.py:894

################################################################################ ## compiler/utils/codegen.sugar.py:896

def gen_method_isValid(e): ## compiler/utils/codegen.sugar.py:898
    generated_code = ""
    if hasattr(e.method.expr, 'header_ref'): ## compiler/utils/codegen.sugar.py:899
        generated_code += add_code(' (pd->headers[{}].pointer != NULL)'.format(e.method.expr.header_ref.id), 899)
    else: ## compiler/utils/codegen.sugar.py:901
        generated_code += add_code(' (pd->headers[{}].pointer != NULL)'.format(format_expr(e.method.expr)), 901)

    return generated_code

def gen_method_setInvalid(e): ## compiler/utils/codegen.sugar.py:904
    generated_code = ""
    if hasattr(e.method.expr, 'header_ref'): ## compiler/utils/codegen.sugar.py:905
        generated_code += add_code(' pd->headers[{}].pointer = NULL'.format(e.method.expr.header_ref.id), 905)
    else: ## compiler/utils/codegen.sugar.py:907
        generated_code += add_code(' pd->headers[{}].pointer = NULL'.format(format_expr(e.method.expr)), 907)

    return generated_code

def gen_method_apply(e): ## compiler/utils/codegen.sugar.py:910
    generated_code = ""
    generated_code += add_code(' {}_apply(STDPARAMS_IN)'.format(e.method.expr.path.name), 910)

    return generated_code

def gen_method_setValid(e): ## compiler/utils/codegen.sugar.py:913
    generated_code = ""
    h = e.method.expr.header_ref ## compiler/utils/codegen.sugar.py:914

    # TODO fix: f must always have an is_vw attribute ## compiler/utils/codegen.sugar.py:916
    def is_vw(f): ## compiler/utils/codegen.sugar.py:917
        if f.get_attr('is_vw') is None: ## compiler/utils/codegen.sugar.py:918
            return False ## compiler/utils/codegen.sugar.py:919
        return f.is_vw ## compiler/utils/codegen.sugar.py:920

    # TODO is this the max size? ## compiler/utils/codegen.sugar.py:922
    length = (sum([f.size if not is_vw(f) else 0 for f in h.type.type_ref.fields])+7)/8 ## compiler/utils/codegen.sugar.py:923

    generated_code += add_code(' pd->headers[{}] = (header_descriptor_t) {{'.format(h.id), 924)
    generated_code += add_code('     .type = {},'.format(h.id), 925)
    generated_code += add_code('     .length = {},'.format(length), 926)
    generated_code += add_code('     .pointer = calloc({}, sizeof(uint8_t)),'.format(h.type.type_ref.byte_width), 927)
    generated_code += add_code("     /*TODO determine and set this field*/", 928)
    generated_code += add_code("     .var_width_field_bitwidth = 0,", 929)
    generated_code += add_code(" };", 930)

    return generated_code

def print_with_base(number, base): ## compiler/utils/codegen.sugar.py:933
    if base == 16: ## compiler/utils/codegen.sugar.py:934
        return "0x{0:x}".format(number) ## compiler/utils/codegen.sugar.py:935
    if base == 2: ## compiler/utils/codegen.sugar.py:936
        return "0b{0:b}".format(number) ## compiler/utils/codegen.sugar.py:937

    return "{}".format(number) ## compiler/utils/codegen.sugar.py:939

def gen_format_expr(e, format_as_value=True, expand_parameters=False): ## compiler/utils/codegen.sugar.py:941
    generated_code = ""
    simple_binary_ops = {'Div':'/', 'Mod':'%',                                 #Binary arithmetic operators ## compiler/utils/codegen.sugar.py:942
                         'Grt':'>', 'Geq':'>=', 'Lss':'<', 'Leq':'<=',         #Binary comparison operators ## compiler/utils/codegen.sugar.py:943
                         'BAnd':'&', 'BOr':'|', 'BXor':'^',                    #Bitwise operators ## compiler/utils/codegen.sugar.py:944
                         'LAnd':'&&', 'LOr':'||',                              #Boolean operators ## compiler/utils/codegen.sugar.py:945
                         'Equ':'==', 'Neq':'!='}                               #Equality operators ## compiler/utils/codegen.sugar.py:946

    # TODO currently, AddSat and SubSat are handled exactly as Add and Sub ## compiler/utils/codegen.sugar.py:948
    complex_binary_ops = {'AddSat':'+', 'SubSat':'-', 'Add':'+', 'Sub':'-', 'Mul':'*', 'Shl':'<<', 'Shr':'>>'} ## compiler/utils/codegen.sugar.py:949
    
    if e is None: ## compiler/utils/codegen.sugar.py:951
        return "FORMAT_EXPR(None)" ## compiler/utils/codegen.sugar.py:952
    elif e.node_type == 'DefaultExpression': ## compiler/utils/codegen.sugar.py:953
        return "default" ## compiler/utils/codegen.sugar.py:954
    elif e.node_type == 'Parameter': ## compiler/utils/codegen.sugar.py:955
        return format_type(e.type) + " " + e.name ## compiler/utils/codegen.sugar.py:956
    elif e.node_type == 'Constant': ## compiler/utils/codegen.sugar.py:957
        if e.type.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:958
            if e.type.size > 32: ## compiler/utils/codegen.sugar.py:959
                def split_text(text, n): ## compiler/utils/codegen.sugar.py:960
                    """Splits the text into chunks that are n characters long.""" ## compiler/utils/codegen.sugar.py:961
                    return [text[i:i+n] for i in range(0, len(text), n)] ## compiler/utils/codegen.sugar.py:962

                byte_width = (e.type.size+7)/8 ## compiler/utils/codegen.sugar.py:964
                const_str_format = '{:0' + str(2 * byte_width) + 'x}' ## compiler/utils/codegen.sugar.py:965
                const_str = const_str_format.format(e.value) ## compiler/utils/codegen.sugar.py:966
                array_const = ", ".join(["0x" + txt for txt in split_text(const_str, 2)]) ## compiler/utils/codegen.sugar.py:967
                var_name = generate_var_name("const", "0x" + const_str) ## compiler/utils/codegen.sugar.py:968

                prepend_statement(' uint8_t {}[] = {{{}}}; // (prepended) compiler/utils/codegen.sugar.py:969\n'.format(var_name, array_const)) ## compiler/utils/codegen.sugar.py:970

                return var_name ## compiler/utils/codegen.sugar.py:972
            else: ## compiler/utils/codegen.sugar.py:973
                value_hint = "" if e.type.size <= 4 or e.value < 2**(e.type.size-1) else " /* probably -{} */".format(2**e.type.size - e.value) ## compiler/utils/codegen.sugar.py:974
                # 4294967136 versus (uint32_t)4294967136 ## compiler/utils/codegen.sugar.py:975
                return "({}){}{}".format(format_type(e.type), print_with_base(e.value, e.base), value_hint) ## compiler/utils/codegen.sugar.py:976
                
        else: ## compiler/utils/codegen.sugar.py:978
            return str(e.value) ## compiler/utils/codegen.sugar.py:979
    elif e.node_type == 'BoolLiteral': ## compiler/utils/codegen.sugar.py:980
        return 'true' if e.value else 'false' ## compiler/utils/codegen.sugar.py:981
    elif e.node_type == 'StringLiteral': ## compiler/utils/codegen.sugar.py:982
        return '"' + e.value + '"'; ## compiler/utils/codegen.sugar.py:983
    elif e.node_type == 'TypeNameExpression': ## compiler/utils/codegen.sugar.py:984
        return format_expr(e.typeName.type_ref); ## compiler/utils/codegen.sugar.py:985

    elif e.node_type == 'Neg': ## compiler/utils/codegen.sugar.py:987
        if e.type.node_type == 'Type_Bits' and not e.type.isSigned: ## compiler/utils/codegen.sugar.py:988
            return '(' + format_type_mask(e.type) + '(' + str(2**e.type.size) + '-' + format_expr(e.expr) + '))' ## compiler/utils/codegen.sugar.py:989
        else: ## compiler/utils/codegen.sugar.py:990
            return '(-' + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:991
    elif e.node_type == 'Cmpl': ## compiler/utils/codegen.sugar.py:992
        return '(' + format_type_mask(e.type) + '(~' + format_expr(e.expr) + '))' ## compiler/utils/codegen.sugar.py:993
    elif e.node_type == 'LNot': ## compiler/utils/codegen.sugar.py:994
        return '(!' + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:995

    elif e.node_type in simple_binary_ops and e.node_type == 'Equ' and e.left.type.size > 32: ## compiler/utils/codegen.sugar.py:997
        return "0 == memcmp({}, {}, ({} + 7) / 8)".format(format_expr(e.left), format_expr(e.right), e.left.type.size) ## compiler/utils/codegen.sugar.py:998

    elif e.node_type in simple_binary_ops: ## compiler/utils/codegen.sugar.py:1000
        return '(({}){}({}))'.format(format_expr(e.left), simple_binary_ops[e.node_type], format_expr(e.right)) ## compiler/utils/codegen.sugar.py:1001

    #Subtraction on unsigned values is performed by adding the negation of the second operand ## compiler/utils/codegen.sugar.py:1003
    elif e.node_type == 'Sub' and e.type.node_type == 'Type_Bits' and not e.type.isSigned: ## compiler/utils/codegen.sugar.py:1004
        return '(' + format_type_mask(e.type) + '(' + format_expr(e.left) + '+(' + str(2**e.type.size) + '-' + format_expr(e.right) + ')))' ## compiler/utils/codegen.sugar.py:1005
    #Right shift on signed values is performed with a shift width check ## compiler/utils/codegen.sugar.py:1006
    elif e.node_type == 'Shr' and e.type.node_type == 'Type_Bits' and e.type.isSigned: ## compiler/utils/codegen.sugar.py:1007
        return '(({1}>{2}) ? 0 : ({0} >> {1}))'.format(format_expr(e.left), format_expr(e.right), e.type.size) ## compiler/utils/codegen.sugar.py:1008
    #These formatting rules MUST follow the previous special cases ## compiler/utils/codegen.sugar.py:1009
    elif e.node_type in complex_binary_ops: ## compiler/utils/codegen.sugar.py:1010
        temp_expr = '(' + format_expr(e.left,expand_parameters=True) + complex_binary_ops[e.node_type] + format_expr(e.right,expand_parameters=True) + ')' ## compiler/utils/codegen.sugar.py:1011
        if e.type.node_type == 'Type_InfInt': ## compiler/utils/codegen.sugar.py:1012
            return temp_expr ## compiler/utils/codegen.sugar.py:1013
        elif e.type.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:1014
            if not e.type.isSigned: ## compiler/utils/codegen.sugar.py:1015
                return '(' + format_type_mask(e.type) + temp_expr + ')' ## compiler/utils/codegen.sugar.py:1016
            else: ## compiler/utils/codegen.sugar.py:1017
                if e.type.size in {8,16,32}: ## compiler/utils/codegen.sugar.py:1018
                    return '((' + format_type(e.type) + ') ' + temp_expr + ')' ## compiler/utils/codegen.sugar.py:1019
                else: ## compiler/utils/codegen.sugar.py:1020
                    addError('formatting an expression', 'Expression of type %s is not supported on int<%s>. (Only int<8>, int<16> and int<32> are supported.)' % (e.node_type, e.type.size)) ## compiler/utils/codegen.sugar.py:1021
                    return '' ## compiler/utils/codegen.sugar.py:1022

    elif e.node_type == 'Mux': ## compiler/utils/codegen.sugar.py:1024
        return '(' + format_expr(e.e0) + '?' + format_expr(e.e1) + ':' + format_expr(e.e2) + ')' ## compiler/utils/codegen.sugar.py:1025

    elif e.node_type == 'Slice': ## compiler/utils/codegen.sugar.py:1027
        return '(' + format_type_mask(e.type) + '(' + format_expr(e.e0) + '>>' + format_expr(e.e2) + '))' ## compiler/utils/codegen.sugar.py:1028

    elif e.node_type == 'Concat': ## compiler/utils/codegen.sugar.py:1030
        return '((' + format_expr(e.left) + '<<' + str(e.right.type.size) + ') | ' + format_expr(e.right) + ')' ## compiler/utils/codegen.sugar.py:1031

    elif e.node_type == 'Cast': ## compiler/utils/codegen.sugar.py:1033
        if e.expr.type.node_type == 'Type_Bits' and not e.expr.type.isSigned and e.expr.type.size == 1 \
                and e.destType.node_type == 'Type_Boolean':        #Cast from bit<1> to bool ## compiler/utils/codegen.sugar.py:1035
            return '(' + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:1036
        elif e.expr.type.node_type == 'Type_Boolean' and e.destType.node_type == 'Type_Bits' and not e.destType.isSigned \
                and e.destType.size == 1:                          #Cast from bool to bit<1> ## compiler/utils/codegen.sugar.py:1038
            return '(' + format_expr(e.expr) + '? 1 : 0)' ## compiler/utils/codegen.sugar.py:1039
        elif e.expr.type.node_type == 'Type_Bits' and e.destType.node_type == 'Type_Bits': ## compiler/utils/codegen.sugar.py:1040
            if e.expr.type.isSigned == e.destType.isSigned: ## compiler/utils/codegen.sugar.py:1041
                if not e.expr.type.isSigned:                       #Cast from bit<w> to bit<v> ## compiler/utils/codegen.sugar.py:1042
                    if e.expr.type.size > e.destType.size: ## compiler/utils/codegen.sugar.py:1043
                        return '(' + format_type_mask(e.destType) + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:1044
                    else: ## compiler/utils/codegen.sugar.py:1045
                        if (expand_parameters): ## compiler/utils/codegen.sugar.py:1046
                            return format_expr(e.expr, expand_parameters = True) ## compiler/utils/codegen.sugar.py:1047
                        else: ## compiler/utils/codegen.sugar.py:1048
                            return format_expr(e.expr) ## compiler/utils/codegen.sugar.py:1049
                else:                                              #Cast from int<w> to int<v> ## compiler/utils/codegen.sugar.py:1050
                    return '((' + format_type(e.destType) + ') ' + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:1051
            elif e.expr.type.isSigned and not e.destType.isSigned: #Cast from int<w> to bit<w> ## compiler/utils/codegen.sugar.py:1052
                return '(' + format_type_mask(e.destType) + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:1053
            elif not e.expr.type.isSigned and e.destType.isSigned: #Cast from bit<w> to int<w> ## compiler/utils/codegen.sugar.py:1054
                if e.destType.size in {8,16,32}: ## compiler/utils/codegen.sugar.py:1055
                    return '((' + format_type(e.destType) + ')' + format_expr(e.expr) + ')' ## compiler/utils/codegen.sugar.py:1056
                else: ## compiler/utils/codegen.sugar.py:1057
                    addError('formatting an expression', 'Cast from bit<%s> to int<%s> is not supported! (Only int<8>, int<16> and int<32> are supported.)' % e.destType.size) ## compiler/utils/codegen.sugar.py:1058
                    return '' ## compiler/utils/codegen.sugar.py:1059
        #Cast from int to bit<w> and int<w> are performed by P4C ## compiler/utils/codegen.sugar.py:1060
        addError('formatting an expression', 'Cast from %s to %s is not supported!' % (pp_type_16(e.expr.type), pp_type_16(e.destType))) ## compiler/utils/codegen.sugar.py:1061
        return '' ## compiler/utils/codegen.sugar.py:1062

    elif e.node_type == 'ListExpression': ## compiler/utils/codegen.sugar.py:1064
        if e.id not in generated_exprs: ## compiler/utils/codegen.sugar.py:1065
            prepend_statement(listexpression_to_buf(e)) ## compiler/utils/codegen.sugar.py:1066
            generated_exprs.add(e.id) ## compiler/utils/codegen.sugar.py:1067
        return '(struct uint8_buffer_s) {{ .buffer =  buffer{}, .buffer_size = buffer{}_size }}'.format(e.id, e.id) ## compiler/utils/codegen.sugar.py:1068
        # return 'buffer{}, buffer{}_size'.format(e.id, e.id) ## compiler/utils/codegen.sugar.py:1069
    elif e.node_type == 'SelectExpression': ## compiler/utils/codegen.sugar.py:1070
        #Generate local variables for select values ## compiler/utils/codegen.sugar.py:1071
        for k in e.select.components: ## compiler/utils/codegen.sugar.py:1072
            varname = gen_var_name(k) ## compiler/utils/codegen.sugar.py:1073
            if k.type.node_type == 'Type_Bits' and k.type.size <= 32: ## compiler/utils/codegen.sugar.py:1074
                prepend_statement(' {} {} = {}; // (prepended) compiler/utils/codegen.sugar.py:1074\n'.format(format_type(k.type), varname, format_expr(k))) ## compiler/utils/codegen.sugar.py:1075
            elif k.type.node_type == 'Type_Bits' and k.type.size % 8 == 0: ## compiler/utils/codegen.sugar.py:1076
                prepend_statement(' uint8_t {}[{}]; // (prepended) compiler/utils/codegen.sugar.py:1076\n'.format(varname, k.type.size/8)) ## compiler/utils/codegen.sugar.py:1077
                prepend_statement(" EXTRACT_BYTEBUF_PACKET(pd, {}, {});' // (prepended) compiler/utils/codegen.sugar.py:1077\n".format(format_expr(k, False), varname)) ## compiler/utils/codegen.sugar.py:1078
            else: ## compiler/utils/codegen.sugar.py:1079
                addError('formatting select expression', 'Select on type %s is not supported!' % pp_type_16(k.type)) ## compiler/utils/codegen.sugar.py:1080

        cases = [] ## compiler/utils/codegen.sugar.py:1082
        for case in e.selectCases: ## compiler/utils/codegen.sugar.py:1083
            cases_tmp = case.keyset.components if case.keyset.node_type == 'ListExpression' else [case.keyset] ## compiler/utils/codegen.sugar.py:1084
            conds = [] ## compiler/utils/codegen.sugar.py:1085
            for k, c in zip(e.select.components, cases_tmp): ## compiler/utils/codegen.sugar.py:1086
                select_type = k.type.node_type ## compiler/utils/codegen.sugar.py:1087
                size = k.type.size #if k.type.node_type == 'Type_Bits' else 0 ## compiler/utils/codegen.sugar.py:1088
                case_type = c.node_type ## compiler/utils/codegen.sugar.py:1089

                if case_type == 'DefaultExpression': ## compiler/utils/codegen.sugar.py:1091
                    conds.append('true /* default */') ## compiler/utils/codegen.sugar.py:1092
                elif case_type == 'Constant' and select_type == 'Type_Bits' and 32 < size and size % 8 == 0: ## compiler/utils/codegen.sugar.py:1093
                    byte_array = int_to_big_endian_byte_array_with_length(c.value, size/8) ## compiler/utils/codegen.sugar.py:1094
                    prepend_statement(' uint8_t {}[{}] = {}; // (prepended) compiler/utils/codegen.sugar.py:1094\n'.format(gen_var_name(c), size/8, byte_array)) ## compiler/utils/codegen.sugar.py:1095
                    conds.append('memcmp({}, {}, {}) == 0'.format(gen_var_name(k), gen_var_name(c), size/8)) ## compiler/utils/codegen.sugar.py:1096
                elif size <= 32: ## compiler/utils/codegen.sugar.py:1097
                    if case_type == 'Range': ## compiler/utils/codegen.sugar.py:1098
                        conds.append('{0} <= {1} && {1} <= {2}'.format(format_expr(c.left), gen_var_name(k), format_expr(c.right))) ## compiler/utils/codegen.sugar.py:1099
                    elif case_type == 'Mask': ## compiler/utils/codegen.sugar.py:1100
                        conds.append('({0} & {1}) == ({2} & {1})'.format(format_expr(c.left), format_expr(c.right), gen_var_name(k))) ## compiler/utils/codegen.sugar.py:1101
                    else: ## compiler/utils/codegen.sugar.py:1102
                        if case_type not in {'Constant'}: #Trusted expressions ## compiler/utils/codegen.sugar.py:1103
                            addWarning('formatting a select case', 'Select statement cases of type %s on %s might not work properly.' ## compiler/utils/codegen.sugar.py:1104
                                       % (case_type, pp_type_16(k.type))) ## compiler/utils/codegen.sugar.py:1105
                        conds.append('{} == {}'.format(gen_var_name(k), format_expr(c))) ## compiler/utils/codegen.sugar.py:1106
                else: ## compiler/utils/codegen.sugar.py:1107
                    addError('formatting a select case', 'Select statement cases of type %s on %s is not supported!' ## compiler/utils/codegen.sugar.py:1108
                             % (case_type, pp_type_16(k.type))) ## compiler/utils/codegen.sugar.py:1109
            cases.append('if({0}){{parser_state_{1}(pd, buf, tables, pstate);}}'.format(' && '.join(conds), format_expr(case.state))) ## compiler/utils/codegen.sugar.py:1110
        return '\nelse\n'.join(cases) ## compiler/utils/codegen.sugar.py:1111

    elif e.node_type == 'PathExpression': ## compiler/utils/codegen.sugar.py:1113
        if e.ref.name == "standard_metadata": ## compiler/utils/codegen.sugar.py:1114
            prepend_statement(pathexpression_to_buf(e)) ## compiler/utils/codegen.sugar.py:1115
            return '(struct uint8_buffer_s) {{ .buffer = buffer{}, .buffer_size = buffer{}_size }}'.format(e.id, e.id) ## compiler/utils/codegen.sugar.py:1116
        if e.ref.name == 'session_0': ## compiler/utils/codegen.sugar.py:1117
            return "global_smem." + e.ref.name ## compiler/utils/codegen.sugar.py:1118
        if is_control_local_var(e.ref.name) and expand_parameters == True: ## compiler/utils/codegen.sugar.py:1119
            return "global_smem." + e.ref.name ## compiler/utils/codegen.sugar.py:1120
        if is_control_local_var(e.ref.name): ## compiler/utils/codegen.sugar.py:1121
            return "local_vars->" + e.ref.name ## compiler/utils/codegen.sugar.py:1122
        if expand_parameters and not e.path.absolute: ## compiler/utils/codegen.sugar.py:1123
            return "parameters." + e.ref.name ## compiler/utils/codegen.sugar.py:1124

        return e.ref.name ## compiler/utils/codegen.sugar.py:1126

    elif e.node_type == 'Member': ## compiler/utils/codegen.sugar.py:1128
        if hasattr(e, 'field_ref'): ## compiler/utils/codegen.sugar.py:1129
            if format_as_value == False: ## compiler/utils/codegen.sugar.py:1130
                return fldid(e.expr.header_ref, e.field_ref) # originally it was fldid2 ## compiler/utils/codegen.sugar.py:1131

            if e.type.size > 32: ## compiler/utils/codegen.sugar.py:1133
                var_name = generate_var_name("hdr_{}_{}".format(e.expr.header_ref.id, e.field_ref.id)) ## compiler/utils/codegen.sugar.py:1134
                byte_size = (e.type.size + 7) / 8 ## compiler/utils/codegen.sugar.py:1135

                prepend_statement(' uint8_t* {}[{}]; // (prepended) compiler/utils/codegen.sugar.py:1136\n'.format(var_name, byte_size)) ## compiler/utils/codegen.sugar.py:1137
                prepend_statement(' EXTRACT_BYTEBUF_PACKET(pd, {}, {}, {}); // (prepended) compiler/utils/codegen.sugar.py:1137\n'.format(e.expr.header_ref.id, e.field_ref.id, var_name)) ## compiler/utils/codegen.sugar.py:1138

                return var_name ## compiler/utils/codegen.sugar.py:1140
            if e.expr.header_ref._type.type_ref.is_metadata and e.expr.path.name == "meta": ## compiler/utils/codegen.sugar.py:1141
                hdrinst = 'header_instance_meta' ## compiler/utils/codegen.sugar.py:1142
            elif e.expr.header_ref._type.type_ref.is_metadata: ## compiler/utils/codegen.sugar.py:1143
                hdrinst = 'header_instance_all_metadatas' ## compiler/utils/codegen.sugar.py:1144
            else: ## compiler/utils/codegen.sugar.py:1145
                hdrinst = e.expr.header_ref.id ## compiler/utils/codegen.sugar.py:1146
            #hdrinst = 'header_instance_all_metadatas' if e.expr.header_ref._type.type_ref.is_metadata else e.expr.header_ref.id ## compiler/utils/codegen.sugar.py:1147
            return '(GET_INT32_AUTO_PACKET(pd, {}, {}))'.format(hdrinst, e.field_ref.id) ## compiler/utils/codegen.sugar.py:1148
        elif hasattr(e, 'header_ref'): ## compiler/utils/codegen.sugar.py:1149
            # TODO do both individual meta fields and metadata instance fields ## compiler/utils/codegen.sugar.py:1150
            if e.header_ref.name == 'metadata': ## compiler/utils/codegen.sugar.py:1151
                generated_code += add_code(' pd->fields.field_instance_{}_{}'.format(e.expr.member, e.member), 1151)
            return e.header_ref.id ## compiler/utils/codegen.sugar.py:1153
        elif e.expr.node_type == 'PathExpression': ## compiler/utils/codegen.sugar.py:1154
            var = e.expr.ref.name ## compiler/utils/codegen.sugar.py:1155

            if e.expr.type.node_type == 'Type_Header': ## compiler/utils/codegen.sugar.py:1157
                h = e.expr.type ## compiler/utils/codegen.sugar.py:1158
                return '(GET_INT32_AUTO_PACKET(pd, header_instance_{}, field_{}_{}))'.format(var, h.name, e.member) ## compiler/utils/codegen.sugar.py:1159
            else: ## compiler/utils/codegen.sugar.py:1160
                generated_code += add_code(' {}.{}'.format(format_expr(e.expr), e.member), 1160)
        else: ## compiler/utils/codegen.sugar.py:1162
            if e.type.node_type in {'Type_Enum', 'Type_Error'}: ## compiler/utils/codegen.sugar.py:1163
                generated_code += add_code(' {}'.format(e.type.members.get(e.member).c_name), 1163)
            elif e.expr('expr', lambda e2: e2.type.name == 'parsed_packet'): ## compiler/utils/codegen.sugar.py:1165
                generated_code += add_code(' pd->fields.field_instance_{}_{}'.format(e.expr.member, e.member), 1165)
            else: ## compiler/utils/codegen.sugar.py:1167
                generated_code += add_code(' {}.{}'.format(format_expr(e.expr), e.member), 1167)
    # TODO some of these are formatted as statements, we shall fix this ## compiler/utils/codegen.sugar.py:1169
    elif e.node_type == 'MethodCallExpression': ## compiler/utils/codegen.sugar.py:1170
        special_methods = { ## compiler/utils/codegen.sugar.py:1171
            ('Member', 'setValid'):     gen_method_setValid, ## compiler/utils/codegen.sugar.py:1172
            ('Member', 'isValid'):      gen_method_isValid, ## compiler/utils/codegen.sugar.py:1173
            ('Member', 'setInvalid'):   gen_method_setInvalid, ## compiler/utils/codegen.sugar.py:1174
            ('Member', 'apply'):        gen_method_apply, ## compiler/utils/codegen.sugar.py:1175
        } ## compiler/utils/codegen.sugar.py:1176

        method = special_methods.get((e.method.node_type, e.method.member)) if e.method.get_attr('member') is not None else None ## compiler/utils/codegen.sugar.py:1178

        if method: ## compiler/utils/codegen.sugar.py:1180
            generated_code += add_code(' {}'.format(method(e)), 1180)
        elif e.arguments.is_vec() and e.arguments.vec != []: ## compiler/utils/codegen.sugar.py:1182
            # TODO is this right? shouldn't e.method always have a .ref? ## compiler/utils/codegen.sugar.py:1183
            if e.method.get_attr('ref') is None: ## compiler/utils/codegen.sugar.py:1184
                mref = e.method.expr.ref ## compiler/utils/codegen.sugar.py:1185
                method_params = mref.type.type_ref.typeParameters ## compiler/utils/codegen.sugar.py:1186
            else: ## compiler/utils/codegen.sugar.py:1187
                mref = e.method.ref ## compiler/utils/codegen.sugar.py:1188
                method_params = mref.type.parameters ## compiler/utils/codegen.sugar.py:1189

            if mref.name == 'digest': ## compiler/utils/codegen.sugar.py:1191
                return gen_format_call_digest(e) ## compiler/utils/codegen.sugar.py:1192
            else: ## compiler/utils/codegen.sugar.py:1193
                return gen_format_call_extern(e, mref, method_params) ## compiler/utils/codegen.sugar.py:1194
        else: ## compiler/utils/codegen.sugar.py:1195
            if e.method('expr').type.node_type == 'Type_Extern': ## compiler/utils/codegen.sugar.py:1196
                if e.method.member in {'advance', 'length'}: ## compiler/utils/codegen.sugar.py:1197
                    raise NotImplementedError('{}.{} is not supported yet!'.format(e.method.expr.type.name, e.method.member)) ## compiler/utils/codegen.sugar.py:1198

                funname = "{}_t_{}".format(e.method.expr.type.name, e.method.member) ## compiler/utils/codegen.sugar.py:1200
                if e.method.member in {'lookahead'}: ## compiler/utils/codegen.sugar.py:1201
                    len = e.typeArguments[0].size ## compiler/utils/codegen.sugar.py:1202
                    extern_type = format_type(e.method.expr.type.methods.get(e.method.member, 'Method').type.returnType) ## compiler/utils/codegen.sugar.py:1203
                    prepend_statement("uint8_t lk_ahead_len={};\n".format(len)) ## compiler/utils/codegen.sugar.py:1204
                    prepend_statement("{}(pd,lk_ahead_len,buf);\n".format(funname)) ## compiler/utils/codegen.sugar.py:1205
                    generated_code += add_code(" (LOOKAHEAD(lk_ahead_len,lkahead_data))", 1205)
                else: ## compiler/utils/codegen.sugar.py:1207
                    extern_inst = format_expr(e.method.expr) ## compiler/utils/codegen.sugar.py:1208
                    extern_type = format_type(e.method.expr.type.methods.get(e.method.member, 'Method').type.returnType) ## compiler/utils/codegen.sugar.py:1209
                    prepend_statement("extern {} {}({}_t);\n".format(extern_type, funname, e.method.expr.type.name)) ## compiler/utils/codegen.sugar.py:1210
                    generated_code += add_code(' {}({})'.format(funname, extern_inst), 1210)
            else: ## compiler/utils/codegen.sugar.py:1212
                funname = format_expr(e.method) ## compiler/utils/codegen.sugar.py:1213
                prepend_statement("extern void {}(SHORT_STDPARAMS);\n".format(funname)) ## compiler/utils/codegen.sugar.py:1214
                generated_code += add_code(' {}(SHORT_STDPARAMS_IN)'.format(funname), 1214)
    elif e.node_type == 'Argument': ## compiler/utils/codegen.sugar.py:1216
        return format_expr(e.expression) ## compiler/utils/codegen.sugar.py:1217
    elif e.node_type == 'StructInitializerExpression': ## compiler/utils/codegen.sugar.py:1218
        generated_code += add_code(' ({}) {{'.format(gen_format_type(e.type)), 1218)
        for component in e.components: ## compiler/utils/codegen.sugar.py:1220
            tref = component.expression.expr("ref.type.type_ref") ## compiler/utils/codegen.sugar.py:1221
            if tref and tref.is_metadata: ## compiler/utils/codegen.sugar.py:1222
                generated_code += add_code(' .{} = (GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_{}_{})),'.format(component.name, tref.name, component.expression.member), 1222)
            else: ## compiler/utils/codegen.sugar.py:1224
                if component.expression.type.size <= 32: ## compiler/utils/codegen.sugar.py:1225
                    generated_code += add_code(' .{} = {},'.format(component.name, gen_format_expr(component.expression)), 1225)
                else: ## compiler/utils/codegen.sugar.py:1227
                    generated_code += add_code(' /* {}/{}b will be initialised afterwards */'.format(component.name, component.expression.type.size), 1227)
        generated_code += add_code(" }", 1228)
    elif e.node_type == 'StructExpression': ## compiler/utils/codegen.sugar.py:1230
        varname = gen_var_name(e) ## compiler/utils/codegen.sugar.py:1231
        prepend_statement(' {} {}; // (prepended) compiler/utils/codegen.sugar.py:1231\n'.format(format_type(e.type), varname)) ## compiler/utils/codegen.sugar.py:1232
        for component in e.components: ## compiler/utils/codegen.sugar.py:1233
            tref = component.expression.expr("ref.type.type_ref") ## compiler/utils/codegen.sugar.py:1234
            if tref and tref.is_metadata: ## compiler/utils/codegen.sugar.py:1235
                prepend_statement(' {}.{} = (GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_{}_{})); // (prepended) compiler/utils/codegen.sugar.py:1235\n'.format(varname, component.name, tref.name, component.expression.member)) ## compiler/utils/codegen.sugar.py:1236
            else: ## compiler/utils/codegen.sugar.py:1237
                if component.expression.type.size <= 32: ## compiler/utils/codegen.sugar.py:1238
                    prepend_statement(' {}.{} = {}; // (prepended) compiler/utils/codegen.sugar.py:1238\n'.format(varname, component.name, gen_format_expr(component.expression))) ## compiler/utils/codegen.sugar.py:1239
                else: ## compiler/utils/codegen.sugar.py:1240
                    indirection = "&" if is_primitive(component.expression.type) else "" ## compiler/utils/codegen.sugar.py:1241
                    refbase = "local_vars->" if is_control_local_var(component.name) else 'parameters.' ## compiler/utils/codegen.sugar.py:1242
                    bitsize = (component.expression.type.size+7)/8 ## compiler/utils/codegen.sugar.py:1243
                    hdrinst = component.expression.expr.header_ref.name ## compiler/utils/codegen.sugar.py:1244
                    fldinst = component.expression.member ## compiler/utils/codegen.sugar.py:1245
                    prepend_statement(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, field_instance_{}_{}, &({}.{})); // (prepended) compiler/utils/codegen.sugar.py:1245\n'.format(hdrinst, hdrinst, fldinst, varname, component.name)) ## compiler/utils/codegen.sugar.py:1246
        generated_code += add_code(' {}'.format(varname), 1246)
    else: ## compiler/utils/codegen.sugar.py:1248
        addError("formatting an expression", "Expression of type %s is not supported yet!" % e.node_type) ## compiler/utils/codegen.sugar.py:1249


    return generated_code

# TODO remove duplication (actions, dataplane) ## compiler/utils/codegen.sugar.py:1252
class types: ## compiler/utils/codegen.sugar.py:1253
    def __init__(self, new_type_env): ## compiler/utils/codegen.sugar.py:1254
        global type_env ## compiler/utils/codegen.sugar.py:1255
        self.env_vars = set() ## compiler/utils/codegen.sugar.py:1256
        for v in new_type_env: ## compiler/utils/codegen.sugar.py:1257
            if v in type_env: ## compiler/utils/codegen.sugar.py:1258
                addWarning('adding a type environment', 'variable {} is already bound to type {}'.format(v, type_env[v])) ## compiler/utils/codegen.sugar.py:1259
            else: ## compiler/utils/codegen.sugar.py:1260
                self.env_vars.add(v) ## compiler/utils/codegen.sugar.py:1261
                type_env[v] = new_type_env[v] ## compiler/utils/codegen.sugar.py:1262

    def __enter__(self): ## compiler/utils/codegen.sugar.py:1264
        global type_env ## compiler/utils/codegen.sugar.py:1265
        return type_env ## compiler/utils/codegen.sugar.py:1266

    def __exit__(self, type, value, traceback): ## compiler/utils/codegen.sugar.py:1268
        global type_env ## compiler/utils/codegen.sugar.py:1269
        for v in self.env_vars: ## compiler/utils/codegen.sugar.py:1270
            del type_env[v] ## compiler/utils/codegen.sugar.py:1271

def gen_format_call_extern(e, mref, method_params): ## compiler/utils/codegen.sugar.py:1273
    generated_code = ""
    # TODO temporary fix, this will be computed later on ## compiler/utils/codegen.sugar.py:1274
    with types({ ## compiler/utils/codegen.sugar.py:1275
        "T": "struct uint8_buffer_s", ## compiler/utils/codegen.sugar.py:1276
        "O": "unsigned", ## compiler/utils/codegen.sugar.py:1277
        "HashAlgorithm": "int", ## compiler/utils/codegen.sugar.py:1278
        "D": "uint16_t", ## compiler/utils/codegen.sugar.py:1279
        "M": "uint32_t", ## compiler/utils/codegen.sugar.py:1280
        "P": "uint32_t*" ## compiler/utils/codegen.sugar.py:1281
    }): ## compiler/utils/codegen.sugar.py:1282
        fmt_params = format_method_parameters(e.arguments, method_params) ## compiler/utils/codegen.sugar.py:1283
        all_params = ", ".join([p for p in [fmt_params, "SHORT_STDPARAMS_IN"] if p != '']) ## compiler/utils/codegen.sugar.py:1284

        return_type = format_type(mref.type.returnType) ## compiler/utils/codegen.sugar.py:1286
        param_types = ", ".join([format_type(tpar) for (par, tpar) in method_parameters_by_type(e.arguments, method_params)] + ["SHORT_STDPARAMS"]) ## compiler/utils/codegen.sugar.py:1287
        prepend_statement(' extern {} {}({}); // (prepended) compiler/utils/codegen.sugar.py:1287\n'.format(format_type(e.type), mref.name, param_types)) ## compiler/utils/codegen.sugar.py:1288
        generated_code += add_code(' {}({})'.format(mref.name, all_params), 1288)

    return generated_code

def gen_format_call_digest(e): ## compiler/utils/codegen.sugar.py:1291
    generated_code = ""
    prepend_statement(" #ifdef PPK_NO_CONTROL_PLANE") ## compiler/utils/codegen.sugar.py:1292
    prepend_statement(" #error \"Generating digest when PPK_NO_CONTROL_PLANE is defined\"") ## compiler/utils/codegen.sugar.py:1293
    prepend_statement(" #endif") ## compiler/utils/codegen.sugar.py:1294

    prepend_statement(' debug("    " T4LIT(<,outgoing) " " T4LIT(Sending digest,outgoing) " to port " T4LIT(%d,port) "\\n", {}); // (prepended) compiler/utils/codegen.sugar.py:1295\n'.format(e.arguments[0].expression.value)) ## compiler/utils/codegen.sugar.py:1296
    for c in e.arguments[1].expression.components: ## compiler/utils/codegen.sugar.py:1297
        cexpr = c.expression ## compiler/utils/codegen.sugar.py:1298
        hdr = cexpr.expr.path.name if cexpr.expr('header_ref', lambda h: h._type._type_ref.is_metadata) else cexpr.expr.header_ref._type_ref.name ## compiler/utils/codegen.sugar.py:1299
        prepend_statement(' dbg_bytes(field_desc(pd, field_instance_{}_{}).byte_addr, ({}+7)/8, "        : "T4LIT({},field)"/"T4LIT({})" = "); // (prepended) compiler/utils/codegen.sugar.py:1299\n'.format(hdr, cexpr.member, cexpr.type.size, cexpr.member, cexpr.type.size)) ## compiler/utils/codegen.sugar.py:1300
    append_statement(" sleep_millis(300);") ## compiler/utils/codegen.sugar.py:1301

    id = e.id ## compiler/utils/codegen.sugar.py:1303
    name = e.typeArguments['Type_Name'][0].path.name ## compiler/utils/codegen.sugar.py:1304
    receiver = e.arguments[0].expression.value ## compiler/utils/codegen.sugar.py:1305
    
    prepend_statement(' ctrl_plane_digest digest{} = create_digest(bg, "{}"); // (prepended) compiler/utils/codegen.sugar.py:1306\n'.format(id, name)) ## compiler/utils/codegen.sugar.py:1307
    for fld in e.arguments[1].expression.components: ## compiler/utils/codegen.sugar.py:1308
        bitsize = fld.expression.type.size ## compiler/utils/codegen.sugar.py:1309
        fe = fld.expression ## compiler/utils/codegen.sugar.py:1310
        hdr = fe.expr.path.name if fe.expr('header_ref', lambda h: h._type._type_ref.is_metadata) else fe.expr.header_ref._type_ref.name ## compiler/utils/codegen.sugar.py:1311
        prepend_statement(' add_digest_field(digest{}, field_desc(pd, field_instance_{}_{}).byte_addr, {}); // (prepended) compiler/utils/codegen.sugar.py:1311\n'.format(id, hdr, fe.member, bitsize)) ## compiler/utils/codegen.sugar.py:1312

    generated_code += add_code(' send_digest(bg, digest{}, {})'.format(id, receiver), 1313)

    return generated_code

################################################################################ ## compiler/utils/codegen.sugar.py:1316

def format_declaration(d, varname_override = None): ## compiler/utils/codegen.sugar.py:1318
    global file_sugar_style ## compiler/utils/codegen.sugar.py:1319
    with SugarStyle("no_comment"): ## compiler/utils/codegen.sugar.py:1320
        return gen_format_declaration(d, varname_override) ## compiler/utils/codegen.sugar.py:1321

# TODO use the variable_name argument in all cases where a variable declaration is created ## compiler/utils/codegen.sugar.py:1323
def format_type(t, variable_name = None, resolve_names = True, addon = ""): ## compiler/utils/codegen.sugar.py:1324
    global file_sugar_style ## compiler/utils/codegen.sugar.py:1325
    with SugarStyle("inline_comment"): ## compiler/utils/codegen.sugar.py:1326
        
        result = gen_format_type(t, resolve_names, variable_name is not None, addon).strip() ## compiler/utils/codegen.sugar.py:1328

        if variable_name is None: ## compiler/utils/codegen.sugar.py:1330
            return result ## compiler/utils/codegen.sugar.py:1331

        split = result.split(" ") ## compiler/utils/codegen.sugar.py:1333
        essential_portion = 2 if split[0] in ['enum', 'struct'] else 1 ## compiler/utils/codegen.sugar.py:1334
        return "{} {}{}".format(" ".join(split[0:essential_portion]), variable_name, " ".join(split[essential_portion:])) ## compiler/utils/codegen.sugar.py:1335

def format_method_parameters(ps, mt): ## compiler/utils/codegen.sugar.py:1337
    global file_sugar_style ## compiler/utils/codegen.sugar.py:1338
    with SugarStyle("inline_comment"): ## compiler/utils/codegen.sugar.py:1339
        return gen_format_method_parameters(ps, mt) ## compiler/utils/codegen.sugar.py:1340

def format_expr(e, format_as_value=True, expand_parameters=False): ## compiler/utils/codegen.sugar.py:1342
    global file_sugar_style ## compiler/utils/codegen.sugar.py:1343
    with SugarStyle("inline_comment"): ## compiler/utils/codegen.sugar.py:1344
        return gen_format_expr(e, format_as_value, expand_parameters) ## compiler/utils/codegen.sugar.py:1345

def format_statement(stmt, ctl=None): ## compiler/utils/codegen.sugar.py:1347
    global enclosing_control ## compiler/utils/codegen.sugar.py:1348
    if ctl is not None: ## compiler/utils/codegen.sugar.py:1349
        enclosing_control = ctl ## compiler/utils/codegen.sugar.py:1350

    global pre_statement_buffer ## compiler/utils/codegen.sugar.py:1352
    global post_statement_buffer ## compiler/utils/codegen.sugar.py:1353
    pre_statement_buffer = "" ## compiler/utils/codegen.sugar.py:1354
    post_statement_buffer = "" ## compiler/utils/codegen.sugar.py:1355

    ret = gen_format_statement(stmt) ## compiler/utils/codegen.sugar.py:1357

    pre_statement_buffer_ret = pre_statement_buffer ## compiler/utils/codegen.sugar.py:1359
    pre_statement_buffer = "" ## compiler/utils/codegen.sugar.py:1360
    post_statement_buffer_ret = post_statement_buffer ## compiler/utils/codegen.sugar.py:1361
    post_statement_buffer = "" ## compiler/utils/codegen.sugar.py:1362
    return pre_statement_buffer_ret + ret + post_statement_buffer_ret ## compiler/utils/codegen.sugar.py:1363


def format_type_mask(t): ## compiler/utils/codegen.sugar.py:1366
    global file_sugar_style ## compiler/utils/codegen.sugar.py:1367
    with SugarStyle("inline_comment"): ## compiler/utils/codegen.sugar.py:1368
        return gen_format_type_mask(t) ## compiler/utils/codegen.sugar.py:1369

def gen_var_name(item, prefix = None): ## compiler/utils/codegen.sugar.py:1371
    generated_code = ""
    if not prefix: ## compiler/utils/codegen.sugar.py:1372
        prefix = "value_" + str(item.node_type) ## compiler/utils/codegen.sugar.py:1373
    generated_code += add_code(' {}_{}'.format(prefix, item.id), 1373)

    return generated_code

def pathexpression_to_buf(expr): ## compiler/utils/codegen.sugar.py:1376
    s = "" ## compiler/utils/codegen.sugar.py:1377
    o = '0' ## compiler/utils/codegen.sugar.py:1378
    for h in expr.type.fields: ## compiler/utils/codegen.sugar.py:1379
        w = '+'+ str(h.type.size) ## compiler/utils/codegen.sugar.py:1380
        s += 'memcpy(buffer%s + (%s+7)/8, field_desc(pd, field_standard_metadata_t_%s).byte_addr, (%s+7)/8);\n' % (expr.id, o, h.name, w) ## compiler/utils/codegen.sugar.py:1381
        o += w ## compiler/utils/codegen.sugar.py:1382
    return 'int buffer{0}_size = ({1}+7)/8;\nuint8_t buffer{0}[buffer{0}_size];\n'.format(expr.id,  o) +s ## compiler/utils/codegen.sugar.py:1383
